{
    "content": "from opentrons import protocol_api\nfrom opentrons import types\nimport math\n\nmetadata = {\n    'protocolName': 'Automated GenFind V3 Blood/serum DNA extraction',\n    'author': 'Eskil Andersen <protocols@opentrons.com>',\n    'source': 'Custom protocol Request',\n    'apiLevel': '2.11'   # CHECK IF YOUR API LEVEL HERE IS UP TO DATE\n                         # IN SECTION 5.2 OF THE APIV2 \"VERSIONING\"\n}\n\n\ndef run(ctx: protocol_api.ProtocolContext):\n\n    [\n     n_samples,\n     is_blood_cells,\n     lwaste,\n     x_offset\n    ] = get_values(  # noqa: F821 (<--- DO NOT REMOVE!)\n        \"n_samples\",\n        \"is_blood_cells\",\n        \"lwaste\",\n        \"x_offset\"\n        )\n\n    sample_vol = 200 if is_blood_cells else 400\n    twelve_well_max_vol = 14*10**3\n    one_well_max_vol = 194*10**3\n    trash_max_vol = 195*10**3\n\n    pip_left_lname = 'p300_multi_gen2'\n    # Saving this variable, might want it later\n    # pip_right_lname = 'p300_single_gen2'\n    tips_lname = 'opentrons_96_filtertiprack_200ul'\n    one_well_resv_lname = 'nest_1_reservoir_195ml'\n    twelve_well_resv_lname = 'nest_12_reservoir_15ml'\n    mag_mod_lname = 'magnetic module gen2'\n    mag_plate_lname = 'nest_96_wellplate_2ml_deep'\n    dest_plate_lname = 'nest_96_wellplate_2ml_deep'\n\n    n_sample_columns = math.floor(n_samples/8)\n\n    lysis_buf_lbb_vol = 2*sample_vol+100\n    prot_k_vol = 0.15*sample_vol\n    bind_bbb_vol = 1.5*sample_vol\n    wash_wbb_vol = 4*sample_vol\n    wash_wbc_vol = 1600\n\n    twelve_well_resv_slot = 4\n    wash_wbb_resv_slot = 1\n    wash_wbc_resv_slot = 2\n    mag_mod_slot = 3\n    liq_trash_resv_slot = 6\n    dest_plate_slot = 9\n    tiprack_slots = [5, 8, 11]\n\n    elution_buffer_vol = sample_vol if is_blood_cells else 40\n\n    # Offsets to pipette away from the magnetic beads\n    sides = [-x_offset, x_offset] * (n_sample_columns // 2)\n\n    mag_height = 5\n\n    # load modules\n\n    '''\n\n    Add your modules here with:\n\n    module_name = ctx.load_module('{module_loadname}', '{slot number}')\n\n    Note: if you are loading a thermocycler, you do not need to specify\n    a slot number - thermocyclers will always occupy slots 7, 8, 10, and 11.\n\n    For all other modules, you can load them on slots 1, 3, 4, 6, 7, 9, 10.\n\n    '''\n    mag_mod = ctx.load_module(mag_mod_lname, mag_mod_slot)\n\n    # load labware\n\n    '''\n\n    Add your labware here with:\n\n    labware_name = ctx.load_labware('{loadname}', '{slot number}')\n\n    If loading labware on a module, you can load with:\n\n    labware_name = module_name.load_labware('{loadname}')\n    where module_name is defined above.\n\n    '''\n    wash_wbb_resv = ctx.load_labware(one_well_resv_lname, wash_wbb_resv_slot,\n                                     label=\"Wash WBB reservoir\")\n    wash_wbc_resv = ctx.load_labware(one_well_resv_lname, wash_wbc_resv_slot,\n                                     label=\"Wash WBC reservoir\")\n    sample_plate = mag_mod.load_labware(mag_plate_lname,\n                                        label=\"sample plate\")\n    twelve_well_resv = ctx.load_labware(twelve_well_resv_lname,\n                                        twelve_well_resv_slot,\n                                        label=\"multi-reagent reservoir\")\n    trash_resv_1 = ctx.load_labware(one_well_resv_lname, liq_trash_resv_slot,\n                                    label=\"liquid waste reservoir\")\n    destination_plate = ctx.load_labware(dest_plate_lname, dest_plate_slot,\n                                         label=\"destination plate\")\n\n    # load tipracks\n\n    '''\n\n    Add your tipracks here as a list:\n\n    For a single tip rack:\n\n    tiprack_name = [ctx.load_labware('{loadname}', '{slot number}')]\n\n    For multiple tip racks of the same type:\n\n    tiprack_name = [ctx.load_labware('{loadname}', 'slot')\n                     for slot in ['1', '2', '3']]\n\n    If two different tipracks are on the deck, use convention:\n    tiprack[number of microliters]\n    e.g. tiprack10, tiprack20, tiprack200, tiprack300, tiprack1000\n\n    '''\n    tipracks = [ctx.load_labware(tips_lname, slot)\n                for slot in tiprack_slots]\n\n    # load instrument\n\n    '''\n    Nomenclature for pipette:\n\n    use 'p'  for single-channel, 'm' for multi-channel,\n    followed by number of microliters.\n\n    p20, m300, p1000 (single channel pipettes)\n    m20, m300 (multi-channel pipettes)\n\n    If loading pipette, load with:\n\n    ctx.load_instrument(\n                        '{pipette api load name}',\n                        pipette_mount (\"left\", or \"right\"),\n                        tip_racks=tiprack\n                        )\n    '''\n    m300 = ctx.load_instrument(\n                              pip_left_lname,\n                              'left',\n                              tip_racks=tipracks\n                              )\n\n    # pipette functions   # INCLUDE ANY BINDING TO CLASS\n\n    '''\n\n    Define all pipette functions, and class extensions here.\n    These may include but are not limited to:\n\n    - Custom pickup functions\n    - Custom drop tip functions\n    - Custom Tip tracking functions\n    - Custom Trash tracking functions\n    - Slow tip withdrawal\n\n    For any functions in your ctx, describe the function as well as\n    describe the parameters which are to be passed in as a docstring below\n    the function (see below).\n\n    def pick_up(pipette):\n        \"\"\"`pick_up()` will pause the ctx when all tip boxes are out of\n        tips, prompting the user to replace all tip racks. Once tipracks are\n        reset, the ctx will start picking up tips from the first tip\n        box as defined in the slot order when assigning the labware definition\n        for that tip box. `pick_up()` will track tips for both pipettes if\n        applicable.\n\n        :param pipette: The pipette desired to pick up tip\n        as definited earlier in the ctx (e.g. m300, m20).\n        \"\"\"\n        try:\n            pipette.pick_up_tip()\n        except ctx_api.labware.OutOfTipsError:\n            ctx.pause(\"Replace empty tip racks\")\n            pipette.reset_tipracks()\n            pipette.pick_up_tip()\n\n    '''\n    def pick_up(pipette):\n        \"\"\"`pick_up()` will pause the ctx when all tip boxes are out of\n        tips, prompting the user to replace all tip racks. Once tipracks are\n        reset, the ctx will start picking up tips from the first tip\n        box as defined in the slot order when assigning the labware definition\n        for that tip box. `pick_up()` will track tips for both pipettes if\n        applicable.\n\n        :param pipette: The pipette desired to pick up tip\n        as definited earlier in the ctx (e.g. m300, m20).\n        \"\"\"\n        nonlocal ctx\n\n        try:\n            pipette.pick_up_tip()\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Replace empty tip racks\")\n            pipette.reset_tipracks()\n            pipette.pick_up_tip()\n\n    # helper functions\n    '''\n    Define any custom helper functions outside of the pipette scope here, using\n    the convention seen above.\n    '''\n\n    def remove_supernatant(volume):\n        '''\n        Remove supernatant from the source columns and dispense it in the trash\n        (the user may remove the waste to liquid waste reservoir if they so\n        choose)\n\n        :param source_columns: The columns to remove supernatant from\n        :param volume: The volume of supernatant to remove\n        '''\n        nonlocal lwaste, trash, m300, sides, sample_columns, liq_trash_tracker\n\n        # Determine where the liquid trash goes: general trash or\n        # liq. trash reservoir\n        trash_target = trash\n        if lwaste:\n            trash_target = liq_trash_tracker.track(volume)\n\n        for col, side in zip(sample_columns, sides):\n            remainining_volume = volume\n            pick_up(m300)\n            while remainining_volume > 0:\n                trash_vol = (200 if remainining_volume > 200 else\n                             remainining_volume)\n                m300.aspirate(trash_vol,\n                              col[0].bottom().move(\n                                types.Point(x=side, y=0, z=1)))\n\n                m300.dispense(trash_vol, trash_target.top())\n                m300.blow_out()  # blow out at trash_target.top()\n                remainining_volume -= trash_vol\n            m300.drop_tip()\n\n    def wash(wash_vol, wash_vol_tracker, mag_engage_time,\n             n_mixes, buffer_name='wash buffer', reuse_tips=True):\n        nonlocal lwaste, m300, sides, sample_columns, mag_mod, ctx, mag_height\n        '''\n        This function repeats a washing procedure two times.\n        Washing procedure:\n        1. Disengage the magnets\n        2. Add wash buffer\n        3. Mix n_mixes times\n        4. Engage the magnets for mag_engage_time minutes\n        5. Remove the supernatant\n        6. Repeat from step 1, one time\n\n        :param wash_vol: The volume of wash buffer to use in microliters\n        :param wash_vol_tracker: VolumeTracker for the wash buffer wells\n        :param mag_engage_time:\n        '''\n        for i in range(0, 2):\n            mag_mod.disengage()\n\n            ctx.comment(\"\\n\\nAdding {} to sample wells\\n\".format(buffer_name))\n            for col in sample_columns:\n                remainining_volume = wash_vol\n                pick_up(m300)\n                while remainining_volume > 0:\n                    vol = 200 if remainining_volume >= 200 else \\\n                        remainining_volume\n                    m300.aspirate(vol, wash_vol_tracker.track(vol))\n                    m300.dispense(vol, col[0])\n                    remainining_volume -= vol\n                mix_vol = 200 if wash_vol - 20 > 200 else wash_vol - 20\n                m300.mix(20, mix_vol)\n                m300.drop_tip()\n\n            mag_mod.engage(height_from_base=mag_height)\n            ctx.delay(minutes=mag_engage_time)\n            ctx.comment(\"\\n\\nRemoving {} supernatant from sample wells\\n\"\n                        .format(buffer_name))\n            remove_supernatant(wash_vol)\n\n    def get_tip_wells(n_columns):\n        '''\n        Returns a list of wells to pick up from and to park tips to\n        for multi-channel pipettes (i.e. the function returns tip wells\n        from the 1st row (A row))\n\n        :param n_columns: How many tip columns are neccesary\n        '''\n        nonlocal tipracks, ctx, m300\n        columns_left = n_columns\n        tip_list = []\n        for rack in tipracks:\n            next_tip = rack.next_tip(8)\n            if next_tip is not None:\n                col_num = int(next_tip.well_name[1:])\n                end_col = columns_left if columns_left + col_num < 12 else 12\n                for col in rack.columns()[col_num-1:end_col]:\n                    if not col[0].has_tip:\n                        # Not enough tips left?:\n                        # Refill tipracks and call the function recursively\n                        # and return tips from the start of the racks\n                        ctx.pause(\"Please refill empty tipracks\")\n                        m300.reset_tipracks()\n                        return get_tip_wells(n_columns)\n                    tip_list.append(col[0])\n                columns_left -= 12-col_num\n        return tip_list\n\n    # Volume Tracking\n    class VolTracker:\n        def __init__(self, labware, well_vol,\n                     start=0, end=8,\n                     mode='reagent',\n                     pip_type='single',\n                     msg='Reset labware volumes'):\n            \"\"\"\n            Voltracker tracks the volume(s) used in a piece of labware\n\n            :param labware: The labware to track\n            :param well_vol: The volume of the liquid in the wells\n            :param pip_type: The pipette type used 'single' or 'multi'\n            :param mode: 'reagent' or 'waste'\n            :param start: The starting well\n            :param end: The ending well\n            :param msg: Message to send to the user when all wells are empty\n\n            \"\"\"\n            self.labware_wells = dict.fromkeys(\n                labware.wells()[start-1:end], 0)\n            self.labware_wells_backup = self.labware_wells.copy()\n            self.well_vol = well_vol\n            self.pip_type = pip_type\n            self.mode = mode\n            self.start = start\n            self.end = end\n            self.msg = msg\n\n            # Parameter error checking\n            if not (pip_type == 'single' or pip_type == 'multi'):\n                raise Exception('Pipette type must be single or multi')\n\n            if not (mode == 'reagent' or mode == 'waste'):\n                raise Exception('mode must be reagent or waste')\n\n        def track(self, vol):\n            '''track() will track how much liquid\n            was used up per well. If the volume of\n            a given well is greater than self.well_vol\n            it will remove it from the dictionary and iterate\n            to the next well which will act as the reservoir.'''\n            well = next(iter(self.labware_wells))\n            vol = vol * 8 if self.pip_type == 'multi' else vol\n            if self.labware_wells[well] + vol >= self.well_vol:\n                del self.labware_wells[well]\n                if len(self.labware_wells) < 1:\n                    ctx.pause(self.msg)\n                    self.labware_wells = self.labware_wells_backup.copy()\n                well = next(iter(self.labware_wells))\n            self.labware_wells[well] += vol\n\n            if self.mode == 'waste':\n                ctx.comment('{}: {} ul of total waste'\n                            .format(well, int(self.labware_wells[well])))\n            else:\n                ctx.comment('{} uL of liquid used from {}'\n                            .format(int(self.labware_wells[well]), well))\n            return well\n    # reagents\n\n    '''\n    Define where all reagents are on the deck using the labware defined above.\n\n    e.g.\n\n    water = reservoir12.wells()[-1]\n    waste = reservoir.wells()[0]\n    samples = plate.rows()[0][0]\n    dnase = tuberack.wells_by_name()['A4']\n\n    '''\n    # Well 1 and 2 of the twelve well resv\n    trash = m300.trash_container.wells()[0].top()  # trash container\n\n    prot_k_tracker = VolTracker(twelve_well_resv, twelve_well_max_vol,\n                                pip_type='multi', start=1, end=1,\n                                msg='Replenish proteinase K buffer in \\\n                                12 well reservoir on deck slot 2, well 1')\n\n    lysis_lbb_tracker = VolTracker(twelve_well_resv, twelve_well_max_vol,\n                                   pip_type='multi', start=2, end=3,\n                                   msg='Replenish Lysis LBB buffer in \\\n                                   12 well reservoir on deck slot 4, \\\n                                   well 2 and 3')\n\n    bind_bbb_tracker = VolTracker(twelve_well_resv, twelve_well_max_vol,\n                                  pip_type='multi', start=4, end=5,\n                                  msg='Replenish Bind BBB buffer in \\\n                                  12 well reservoir on deck slot 4 \\\n                                  in well 4 and 5')\n\n    elution_buf_tracker = VolTracker(twelve_well_resv, twelve_well_max_vol,\n                                     pip_type='multi', start=6, end=7,\n                                     msg='Replenish elution buffer in \\\n                                     12 well reservoir on deck slot 4 \\\n                                     in well 6 and 7')\n\n    wash_wbb_tracker = VolTracker(wash_wbb_resv, one_well_max_vol,\n                                  pip_type='multi', start=1, end=1,\n                                  msg='Replenish Wash WBB buffer in \\\n                                  reservoir on deck slot 2')\n\n    wash_wbc_tracker = VolTracker(wash_wbc_resv, one_well_max_vol,\n                                  pip_type='multi', start=1, end=1,\n                                  msg='Replenish Wash WBB buffer in \\\n                                  reservoir on deck slot 2')\n\n    liq_trash_tracker = VolTracker(trash_resv_1, trash_max_vol,\n                                   pip_type='multi', mode='waste',\n                                   start=1, end=1, msg='Empty liquid waste')\n    # plate, tube rack maps\n\n    '''\n    Define any plate or tube maps here.\n\n    e.g.\n\n    plate_wells_by_row = [well for row in plate.rows() for well in row]\n\n    '''\n    sample_columns = sample_plate.columns()[0:n_sample_columns]\n    destination_columns = destination_plate.columns()[0:n_sample_columns]\n\n    # ctx\n\n    '''\n\n    Include header sections as follows for each \"section\" of your ctx.\n\n    Section can be defined as a step in a bench ctx.\n\n    e.g.\n\n    ctx.comment('\\n\\nMOVING MASTERMIX TO SAMPLES IN COLUMNS 1-6\\n')\n\n    for .... in ...:\n        ...\n        ...\n\n    ctx.comment('\\n\\nRUNNING THERMOCYCLER PROFILE\\n')\n\n    ...\n    ...\n    ...\n\n\n    '''\n\n    # step 1 - Add 2 samples volumes + 100 uL of lysis buffer BBB\n    ctx.comment(\"\\n\\nStep 1: Adding Lysis BBB to samples\\n\")\n    for col in sample_columns:\n        m300.transfer(lysis_buf_lbb_vol,\n                      lysis_lbb_tracker.track(lysis_buf_lbb_vol), col[0])\n\n    # step 2 - Add proteinase K to samples and mix 10 times gently to\n    # prevent bubble formation\n    ctx.comment(\"\\n\\nStep 2: Adding Proteinase K and mixing\\n\")\n    total_well_vol = sample_vol + lysis_buf_lbb_vol + prot_k_vol\n    mix_vol = 200 if total_well_vol - 20 > 200 else total_well_vol - 20\n    for col in sample_columns:\n        pick_up(m300)\n        m300.transfer(prot_k_vol, prot_k_tracker.track(prot_k_vol),\n                      col[0], new_tip='never')\n        # Mix slowly to prevent bubble formation\n        m300.mix(20, mix_vol, col[0], 1/3)\n        m300.drop_tip()\n\n    # Step 3 - Incubate the samples with the buffer and enzyme\n    ctx.comment(\"\\n\\nStep 3: Incubating samples\\n\")\n    ctx.comment(\"Incubation step: Seal the sample plate and incubate \" +\n                \"samples for 10 minutes at 37 C or 30 minutes at room \" +\n                \"temperature (see bench protocol step 3)\")\n\n    ctx.pause(\"Resume when the sample plate has been reinserted \" +\n              \"on the mag deck and the Bind BBB buffer has been vortexed \" +\n              \"or inverted 20 times and added to the 12 well reservoir\")\n\n    # Step 4 - Add Bind BBB buffer and mix gently\n    ctx.comment(\"\\n\\nStep 4: Adding Bind BBB and mixing\\n\")\n    total_well_vol += bind_bbb_vol\n    mix_vol = 200 if total_well_vol - 10 > 200 else total_well_vol - 10\n    bbb_vol_used = 0\n    for col in sample_columns:\n        pick_up(m300)\n        m300.transfer(bind_bbb_vol, bind_bbb_tracker.track(bind_bbb_vol),\n                      col[0], new_tip='never')\n        bbb_vol_used += bind_bbb_vol\n        m300.mix(20, mix_vol, col[0], 1/3)\n        m300.drop_tip()\n\n    # Step 5 - Incubate samples for 5 minutes\n    ctx.comment(\"\\n\\nStep 5: Incubating samples with Bind BBB\\n\")\n    ctx.comment('Beginning 5 minutes incubation at room temperature')\n    ctx.delay(minutes=5)\n\n    # Step 6 - Engage magnets for 15 minutes\n    ctx.comment(\"\\n\\nStep 6: Engaging magnets for 15 minutes\\n\")\n    mag_mod.engage(height_from_base=mag_height)\n    ctx.delay(minutes=15)\n\n    # step 7 - Aspirate off the supernatant and dump it in the waste\n    ctx.comment(\"\\n\\nStep 7: Transferring supernantant to waste\\n\")\n    remove_supernatant(total_well_vol)\n    total_well_vol = 0\n\n    # Step 8 through 11: Wash the beads two times using Wash WBB buffer\n    ctx.comment(\"\\n\\nStep 8-11: Washing beads with Wash WBB\\n\")\n    wash(wash_wbb_vol, wash_wbb_tracker, 10, 20, \"Wash WBB\")\n\n    # Steps 12-15 - Disengage magnets and wash with buffer \"Wash WBC\"\n    # Engage magnets, and discard supernatant - repeat 2x\n    ctx.comment(\"\\n\\nStep 12-15: Washing beads with Wash WBC\\n\")\n    wash(wash_wbc_vol, wash_wbc_tracker, 10, 20, \"Wash WBC\")\n\n    # Step 16 - Add elution buffer and mix\n    ctx.comment(\"\\n\\nStep 16: Adding elution buffer to samples and mixing\\n\")\n    total_well_vol = elution_buffer_vol\n    tips = get_tip_wells(len(sample_columns))\n    for col, tip_well in zip(sample_columns, tips):\n        m300.pick_up_tip(tip_well)\n        m300.transfer(elution_buffer_vol,\n                      elution_buf_tracker.track(elution_buffer_vol), col[0],\n                      new_tip='never')\n        mix_vol = 200 if total_well_vol - 10 > 200 else total_well_vol - 10\n        m300.mix(20, mix_vol)\n        m300.drop_tip(tip_well)\n\n    # Step 17 - Incubate samples for two minutes and mix with parked tips\n    ctx.comment(\"\\n\\nStep 17: Incubating samples and mixing 2nd time\\n\")\n    ctx.delay(minutes=2)\n    for col, tip_well in zip(sample_columns, tips):\n        m300.pick_up_tip(tip_well)\n        mix_vol = 200 if total_well_vol - 10 > 200 else total_well_vol - 10\n        m300.mix(20, mix_vol, col[0])\n        m300.drop_tip()\n\n    # Step 18 - Engage magnets (5 min) and transfer\n    # the eluted material from the sample plate to the destination plate\n    ctx.comment('\\n\\nStep 18: Engaging magnets and transferring eluted ' +\n                'samples to the destination plate\\n')\n    mag_mod.engage(height_from_base=mag_height)\n    ctx.delay(minutes=5)\n    for s_col, d_col, side in zip(sample_columns, destination_columns, sides):\n        pass\n        remainining_volume = elution_buffer_vol\n        pick_up(m300)\n        while remainining_volume > 0:\n            vol = (200 if remainining_volume > 200 else\n                   remainining_volume)\n            m300.aspirate(vol,\n                          s_col[0].bottom().move(\n                            types.Point(x=side, y=0, z=1)))\n\n            m300.dispense(vol, d_col[0])\n            remainining_volume -= vol\n        m300.drop_tip()\n    ctx.comment(\"\\n\\n ~~~~ End of protocol ~~~~\")\n",
    "custom_labware_defs": [],
    "fields": [
        {
            "default": 32,
            "label": "Number of samples",
            "name": "n_samples",
            "type": "int"
        },
        {
            "default": 1,
            "label": "X offset for bead aspiration",
            "name": "x_offset",
            "type": "int"
        },
        {
            "label": "Blood cells or serum?",
            "name": "is_blood_cells",
            "options": [
                {
                    "label": "Blood cells",
                    "value": true
                },
                {
                    "label": "Serum",
                    "value": false
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Liquid waste reservoir",
            "name": "lwaste",
            "options": [
                {
                    "label": "Use a liquid waste reservoir (slot 6)",
                    "value": true
                },
                {
                    "label": "Use regular trash for liquid waste",
                    "value": false
                }
            ],
            "type": "dropDown"
        }
    ],
    "instruments": [
        {
            "mount": "left",
            "name": "p300_multi_gen2"
        }
    ],
    "labware": [
        {
            "name": "Wash WBB reservoir on 1",
            "share": false,
            "slot": "1",
            "type": "nest_1_reservoir_195ml"
        },
        {
            "name": "Wash WBC reservoir on 2",
            "share": false,
            "slot": "2",
            "type": "nest_1_reservoir_195ml"
        },
        {
            "name": "sample plate on Magnetic Module GEN2 on 3",
            "share": false,
            "slot": "3",
            "type": "nest_96_wellplate_2ml_deep"
        },
        {
            "name": "multi-reagent reservoir on 4",
            "share": false,
            "slot": "4",
            "type": "nest_12_reservoir_15ml"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 200 \u00b5L on 5",
            "share": false,
            "slot": "5",
            "type": "opentrons_96_filtertiprack_200ul"
        },
        {
            "name": "liquid waste reservoir on 6",
            "share": false,
            "slot": "6",
            "type": "nest_1_reservoir_195ml"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 200 \u00b5L on 8",
            "share": false,
            "slot": "8",
            "type": "opentrons_96_filtertiprack_200ul"
        },
        {
            "name": "destination plate on 9",
            "share": false,
            "slot": "9",
            "type": "nest_96_wellplate_2ml_deep"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 200 \u00b5L on 11",
            "share": false,
            "slot": "11",
            "type": "opentrons_96_filtertiprack_200ul"
        },
        {
            "name": "Opentrons Fixed Trash on 12",
            "share": false,
            "slot": "12",
            "type": "opentrons_1_trash_1100ml_fixed"
        }
    ],
    "metadata": {
        "apiLevel": "2.11",
        "author": "Eskil Andersen <protocols@opentrons.com>",
        "protocolName": "Automated GenFind V3 Blood/serum DNA extraction",
        "source": "Custom protocol Request"
    },
    "modules": []
}