{
    "content": "from opentrons import protocol_api\nfrom opentrons.protocol_api.contexts import InstrumentContext\nfrom opentrons.protocol_api.labware import Well, Labware\nfrom opentrons.types import Point\nimport math\n\nmetadata = {\n    'protocolName': '357404: Slide sample antibody staining',\n    'author': 'Eskil Andersen <protocols@opentrons.com>',\n    'source': 'Custom Protocol Request',\n    'apiLevel': '2.11'   # CHECK IF YOUR API LEVEL HERE IS UP TO DATE\n                         # IN SECTION 5.2 OF THE APIV2 \"VERSIONING\"\n}\n\n\ndef run(ctx: protocol_api.ProtocolContext):\n\n    [n_slots,\n     n_last_samples,\n     vol_reagent,\n     dispense_steps,\n     is_start_after_1st_incbn,\n     is_stop_after_1st_incbn,\n     tuberack_lname,\n     pipette_offset,\n     is_dry_run,\n     t_per_block,\n     is_multi_disp_reags,\n     is_reuse_reag_tips,\n     is_reuse_wash_tips,\n     temp_mod_lname,\n     p1000_slot,\n     well_edge_offset,\n     is_use_custom_block,\n     custom_labware_lname] = get_values(  # noqa: F821\n     \"n_slots\",\n     \"n_last_samples\",\n     \"vol_reagent\",\n     \"dispense_steps\",\n     \"is_start_after_1st_incbn\",\n     \"is_stop_after_1st_incbn\",\n     \"tuberack_lname\",\n     \"pipette_offset\",\n     \"is_dry_run\",\n     \"t_per_block\",\n     \"is_multi_disp_reags\",\n     \"is_reuse_reag_tips\",\n     \"is_reuse_wash_tips\",\n     \"temp_mod_lname\",\n     \"p1000_slot\",\n     \"well_edge_offset\",\n     \"is_use_custom_block\",\n     \"custom_labware_lname\")\n\n    # Definitions for loading labware, tipracks and pipettes.\n    slide_block_lname = (custom_labware_lname if is_use_custom_block\n                         else 'customslideblockv2_8_wellplate')\n    slide_blocks_loader = {'lname': slide_block_lname,\n                           'slots': [1, 4, 5, 7, 8, 9, 10, 11]}\n    tuberack_slot = '3'\n    temp_mod_loader = {'lname': temp_mod_lname, 'slot': tuberack_slot}\n    reservoir_loader = {'lname': 'agilent_1_reservoir_290ml', 'slot': '2'}\n    # The tuberack is loaded on temperature module\n    tuberack_loader = {'lname': tuberack_lname, 'slot': tuberack_slot}\n\n    tiprack_1000_loader = {'lname': 'opentrons_96_tiprack_1000ul',\n                           'slots': ['6']}\n    p1000_loader = {'lname': 'p1000_single_gen2', 'mount': p1000_slot}\n\n    verbose = False\n\n    if temp_mod_lname and 'Aluminum' not in tuberack_lname:\n        raise Exception(\"You must select an aluminum block tuberack when \"\n                        \"using the temperature module, you selected {}\"\n                        .format(tuberack_lname))\n\n    if not 0 < n_slots < 9:\n        raise Exception(\"The number of blocks have to be between 1 and 8\")\n\n    if not 0 < n_last_samples < 9:\n        raise Exception(\"The number of samples on the last block have to be\"\n                        + \"between 1 and 8\")\n\n    if is_start_after_1st_incbn and is_stop_after_1st_incbn:\n        raise Exception(\"Incompatible parameters: Protocol cannot both stop \"\n                        + \"after the first incubation and skip the first \"\n                        + \"incubation\")\n\n    '''\n\n    Add your modules here with:\n\n    module_name = ctx.load_module('{module_loadname}', '{slot number}')\n\n    Note: if you are loading a thermocycler, you do not need to specify\n    a slot number - thermocyclers will always occupy slots 7, 8, 10, and 11.\n\n    For all other modules, you can load them on slots 1, 3, 4, 6, 7, 9, 10.\n\n    '''\n    # load modules\n    temp_mod = None\n    if temp_mod_loader['lname']:\n        temp_mod = ctx.load_module(temp_mod_loader['lname'],\n                                   temp_mod_loader['slot'])\n\n    # load labware\n    # Labware: 290 mL reservoir, Tuberack for reagents, slide blocks\n    reservoir = ctx.load_labware(reservoir_loader['lname'],\n                                 reservoir_loader['slot'])\n    tuberack = None\n    if temp_mod is not None:\n        tuberack = temp_mod.load_labware(tuberack_loader['lname'])\n    else:\n        tuberack = ctx.load_labware(tuberack_loader['lname'],\n                                    tuberack_loader['slot'])\n    slide_blocks = []\n    for slot in slide_blocks_loader['slots'][:n_slots]:\n        slide_block = ctx.load_labware(slide_blocks_loader['lname'], slot)\n        slide_blocks.append(slide_block)\n\n    '''\n\n    Add your labware here with:\n\n    labware_name = ctx.load_labware('{loadname}', '{slot number}')\n\n    If loading labware on a module, you can load with:\n\n    labware_name = module_name.load_labware('{loadname}')\n    where module_name is defined above.\n\n    '''\n    # load tipracks\n\n    '''\n\n    Add your tipracks here as a list:\n\n    For a single tip rack:\n\n    tiprack_name = [ctx.load_labware('{loadname}', '{slot number}')]\n\n    For multiple tip racks of the same type:\n\n    tiprack_name = [ctx.load_labware('{loadname}', 'slot')\n                     for slot in ['1', '2', '3']]\n\n    If two different tipracks are on the deck, use convention:\n    tiprack[number of microliters]\n    e.g. tiprack10, tiprack20, tiprack200, tiprack300, tiprack1000\n\n    '''\n    # Load 1000 uL tips on 6 and 9\n    tiprack_1000s = \\\n        [ctx.load_labware(tiprack_1000_loader['lname'], slot)\n         for slot in tiprack_1000_loader['slots']]\n\n    # load instrument\n\n    '''\n    Nomenclature for pipette:\n\n    use 'p'  for single-channel, 'm' for multi-channel,\n    followed by number of microliters.\n\n    p20, p300, p1000 (single channel pipettes)\n    m20, m300 (multi-channel pipettes)\n\n    If loading pipette, load with:\n\n    ctx.load_instrument(\n                        '{pipette api load name}',\n                        pipette_mount (\"left\", or \"right\"),\n                        tip_racks=tiprack\n                        )\n    '''\n    # Load p1000 gen2\n    p1000 = ctx.load_instrument(\n                              p1000_loader['lname'],\n                              p1000_loader['mount'],\n                              tip_racks=tiprack_1000s\n                              )\n\n    # pipette functions   # INCLUDE ANY BINDING TO CLASS\n\n    '''\n\n    Define all pipette functions, and class extensions here.\n    These may include but are not limited to:\n\n    - Custom pickup functions\n    - Custom drop tip functions\n    - Custom Tip tracking functions\n    - Custom Trash tracking functions\n    - Slow tip withdrawal\n\n    For any functions in your protocol, describe the function as well as\n    describe the parameters which are to be passed in as a docstring below\n    the function (see below).\n\n    def pick_up(pipette):\n        \"\"\"`pick_up()` will pause the protocol when all tip boxes are out of\n        tips, prompting the user to replace all tip racks. Once tipracks are\n        reset, the protocol will start picking up tips from the first tip\n        box as defined in the slot order when assigning the labware definition\n        for that tip box. `pick_up()` will track tips for both pipettes if\n        applicable.\n\n        :param pipette: The pipette desired to pick up tip\n        as definited earlier in the protocol (e.g. p300, m20).\n        \"\"\"\n        try:\n            pipette.pick_up_tip()\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Replace empty tip racks\")\n            pipette.reset_tipracks()\n            pipette.pick_up_tip()\n\n    '''\n    def pick_up(pipette):\n        \"\"\"`pick_up()` will pause the protocol when all tip boxes are out of\n        tips, prompting the user to replace all tip racks. Once tipracks are\n        reset, the protocol will start picking up tips from the first tip\n        box as defined in the slot order when assigning the labware definition\n        for that tip box. `pick_up()` will track tips for both pipettes if\n        applicable.\n\n        :param pipette: The pipette desired to pick up tip\n        as definited earlier in the protocol (e.g. p300, m20).\n        \"\"\"\n        try:\n            pipette.pick_up_tip()\n        except protocol_api.labware.OutOfTipsError:\n            flash_lights()\n            ctx.pause(\"Replace empty tip racks\")\n            pipette.reset_tipracks()\n            pipette.pick_up_tip()\n    # helper functions\n    '''\n    Define any custom helper functions outside of the pipette scope here, using\n    the convention seen above.\n\n    e.g.\n\n    def remove_supernatant(vol, index):\n        \"\"\"\n        function description\n\n        :param vol:\n\n        :param index:\n        \"\"\"\n\n\n    '''\n    class VolTracker:\n        def __init__(self, labware: Labware,\n                     well_vol: float = 0,\n                     start: int = 1, end: int = 8,\n                     mode: str = 'reagent',\n                     pip_type: str = 'single',\n                     msg: str = 'Refill labware volumes'):\n            \"\"\"\n            Voltracker tracks the volume(s) used in a piece of labware\n\n            :param labware: The labware to track\n            :param well_vol: The volume of the liquid in the wells, if using a\n            multi-pipette with a well plate, treat the plate like a reservoir,\n            i.e. start=1, end=1, well_vol = 8 * vol of each individual well.\n            :param pip_type: The pipette type used 'single' or 'multi'\n            :param mode: 'reagent' or 'waste'\n            :param start: The starting well\n            :param end: The ending well\n            :param msg: Message to send to the user when all wells are empty\n            (or full when in waste mode)\n\n            \"\"\"\n            self.labware_wells = dict.fromkeys(\n                labware.wells()[start-1:end], 0)\n            self.labware_wells_backup = self.labware_wells.copy()\n            self.well_vol = well_vol\n            self.pip_type = pip_type\n            self.mode = mode\n            self.start = start\n            self.end = end\n            self.msg = msg\n\n            # Parameter error checking\n            if not (pip_type == 'single' or pip_type == 'multi'):\n                raise Exception('Pipette type must be single or multi')\n\n            if not (mode == 'reagent' or mode == 'waste'):\n                raise Exception('mode must be reagent or waste')\n\n        def flash_lights(self):\n            \"\"\"\n            Flash the lights of the robot to grab the users attention\n            \"\"\"\n            initial_light_state = ctx.rail_lights_on\n            opposite_state = not initial_light_state\n            for _ in range(5):\n                ctx.set_rail_lights(opposite_state)\n                ctx.delay(seconds=0.5)\n                ctx.set_rail_lights(initial_light_state)\n                ctx.delay(seconds=0.5)\n\n        def get_current_vol(self):\n            \"\"\"\n            Return the current well's volume in uL\n            \"\"\"\n            well = next(iter(self.labware_wells))\n            remaining_vol = self.well_vol - self.labware_wells[well]\n            return remaining_vol\n\n        def track(self, vol: float) -> Well:\n            '''track() will track how much liquid\n            was used up per well. If the volume of\n            a given well is greater than self.well_vol\n            it will remove it from the dictionary and iterate\n            to the next well which will act as the reservoir.'''\n            well = next(iter(self.labware_wells))\n            # Treat plates like reservoirs and add 8 well volumes together\n            vol = vol * 8 if self.pip_type == 'multi' else vol\n            if self.labware_wells[well] + vol >= self.well_vol:\n                del self.labware_wells[well]\n                if len(self.labware_wells) < 1:\n                    flash_lights()\n                    ctx.pause(self.msg)\n                    self.labware_wells = self.labware_wells_backup.copy()\n                well = next(iter(self.labware_wells))\n            self.labware_wells[well] += vol\n\n            if self.mode == 'waste':\n                ctx.comment('{}: {} ul of total waste'\n                            .format(well, int(self.labware_wells[well])))\n            else:\n                ctx.comment('{} uL of liquid used from {}'\n                            .format(int(self.labware_wells[well]), well))\n            return well\n\n    def wash(pip: InstrumentContext,\n             vol: float, source: VolTracker, dest: list,\n             do_dry_run: bool = False, pip_offset: float = 0,\n             steps: int = 5, do_reuse_tip: bool = False):\n        \"\"\" This function is used to aspirate a washing buffer and then\n        dispense it over a well using a moving dispense\n\n        :param pip: The pipette to use for washing aspirations/dispenses\n        :param vol: The volume to wash with, e.g. 4000 uL\n        :param source: VolTracker tracking a labware source of wash buffer,\n        e.g. a reservoir\n        :param dest: A list of wells to dispense to\n        :param do_dry_run: If this argument is true then pipette tips will be\n        returned to the rack they come from.\n        :param pip_offset: Millimeter offset from the bottom of the well\n        (i.e. the Shandon coverplate mouth)\n        :param do_reuse_tip: Use only one tip for aspirating PBS / Washing\n        each slide well?\n        \"\"\"\n        max_vol = pip.max_volume\n        vol_backup = vol\n        for well in dest:\n            if not pip.has_tip:\n                pick_up(pip)\n            while vol > 0:\n                aspiration_vol = vol if vol < max_vol else max_vol\n                pip.aspirate(aspiration_vol, source.track(aspiration_vol))\n                dispense_while_moving(pip, well, aspiration_vol, steps,\n                                      verbose, pip_offset)\n                vol -= aspiration_vol\n            if do_dry_run and not do_reuse_tip:\n                pip.return_tip()\n            elif not do_reuse_tip:\n                pip.drop_tip()\n            vol = vol_backup\n        if do_reuse_tip and not do_dry_run:\n            pip.drop_tip()\n        elif do_dry_run and pip.has_tip:\n            pip.return_tip()\n\n    def single_dispense_reagent_p1000(source: VolTracker, dest: list,\n                                      do_dry_run: bool = False,\n                                      pip_offset: float = 0,\n                                      steps: int = 5,\n                                      do_reuse_tip: bool = False):\n        \"\"\" This function aspirates a single dose of a reagent and transfers\n        it to a single well with each transfer. (As opposed to the multi\n        version of this function which can pick up to 9 doses of reagents\n        and then dispenses them to 9 wells in one go.)\n\n        :param source: VolTracker object for the reagent's source.\n        :param dest: A list of wells to dispense to\n        :param do_dry_run: If this argument is true then pipette tips will be\n        returned to the rack they come from.\n        :param pip_offset: Millimeter offset from the bottom of the well\n        (i.e. the Shandon coverplate mouth). positive numbers to raise,\n        negative to lower the pipette.\n        :param do_reuse_tip: Use only one tip for aspirating PBS / Washing\n        each slide well?\n        \"\"\"\n        nonlocal p1000\n        for well in dest:\n            aspiration_vol = 100\n            if not p1000.has_tip:\n                pick_up(p1000)\n            p1000.aspirate(aspiration_vol, source.track(aspiration_vol))\n            dispense_while_moving(p1000, well, aspiration_vol, steps)\n            if do_dry_run and not do_reuse_tip:\n                p1000.return_tip()\n            elif not do_reuse_tip:\n                p1000.drop_tip()\n        # Drop the tip after all wells have been dispensed to if the tip is\n        # being reused for this reagent dispense\n        if do_reuse_tip and not do_dry_run:\n            p1000.drop_tip()\n        elif do_dry_run and p1000.has_tip:\n            p1000.return_tip()\n\n    def multi_dispense_reagent_p1000(source: VolTracker, dest: list,\n                                     do_dry_run: bool = False,\n                                     pip_offset: float = 0,\n                                     steps: int = 5,\n                                     do_reuse_tip: bool = False):\n        \"\"\" The multi version of the reagent transfer function which can\n        pick up to 9 doses of reagents and then dispenses them to 9 wells in\n        one go.\n\n        :param source: VolTracker object for the reagent's source.\n        :param dest: A list of wells to dispense to\n        :param do_dry_run: If this argument is true then pipette tips will be\n        returned to the rack they come from.\n        :param pip_offset: Millimeter offset from the bottom of the well\n        (i.e. the Shandon coverplate mouth). positive numbers to raise,\n        negative to lower the pipette.\n        :param do_reuse_tip: Use only one tip for aspirating PBS / Washing\n        each slide well?\n        \"\"\"\n        nonlocal p1000\n        n_wells = len(dest)\n        track_vol = 0\n        for i, d_well in enumerate(dest):\n            remaining_wells = n_wells - i\n            aspiration_vol = 0\n            if track_vol < 100:\n                aspiration_vol = 905 if remaining_wells > 9 else \\\n                    remaining_wells * 100 + 5\n                if p1000.has_tip:\n                    if do_reuse_tip:\n                        p1000.blow_out(ctx.fixed_trash['A1'])\n                    else:\n                        if do_dry_run:\n                            p1000.return_tip()\n                        else:\n                            p1000.drop_tip()\n                        pick_up(p1000)\n                else:\n                    pick_up(p1000)\n                # There's a chance that the remaining volume in the reagent\n                # tube is less than the volume we want to aspirate. We don't\n                # want the remaining volume to go to waste since it could be\n                # a lot, so we aspirate it here and subtract it from the total\n                tube_vol_asp = source.get_current_vol() - 5\n                if aspiration_vol > tube_vol_asp:\n                    p1000.aspirate(\n                        tube_vol_asp, source.track(tube_vol_asp))\n                    remaining_asp_vol = aspiration_vol - tube_vol_asp\n                    p1000.aspirate(remaining_asp_vol,\n                                   source.track(remaining_asp_vol))\n                else:\n                    p1000.aspirate(\n                        aspiration_vol, source.track(aspiration_vol))\n                track_vol = aspiration_vol\n            dispense_while_moving(p1000, d_well, 100, steps)\n            track_vol -= 100\n        # Drop the tip after we're done\n        if p1000.has_tip:\n            if do_dry_run:\n                p1000.return_tip()\n            else:\n                p1000.drop_tip()\n\n    def flash_lights():\n        \"\"\"\n        Flash the lights of the robot to grab the users attention\n        \"\"\"\n        initial_light_state = ctx.rail_lights_on\n        opposite_state = not initial_light_state\n        for _ in range(5):\n            ctx.set_rail_lights(opposite_state)\n            ctx.delay(seconds=0.5)\n            ctx.set_rail_lights(initial_light_state)\n            ctx.delay(seconds=0.5)\n\n    def pause(msg: str, time_elapsed_sec: float = 0,\n              pause_period_minutes: int = 60, do_dry_run: bool = False):\n        \"\"\" Pauses the protocol for an incubation period, but subtracts the\n        time elapsed for some preparative process from the total pause period.\n        Also tells the user what the slides are being incubated with.\n        \"\"\"\n        msg_template = \"Incubating slides with {}\"\n        dry_run_msg = \"(Dry run): \"\n        if time_elapsed_sec > pause_period_minutes*60:\n            ctx.comment(\n                \"Skipping pause for incubation, the pause period has already \"\n                + \"elapsed during the reagent transfer of {}\".format(msg))\n            return\n        min_elapsed = math.ceil(time_elapsed_sec/60)\n        pause_period_secs = 60 - time_elapsed_sec % 60\n        pause_period_minutes -= min_elapsed\n        if not do_dry_run:\n            ctx.delay(minutes=pause_period_minutes, seconds=pause_period_secs,\n                      msg=msg_template.format(msg))\n        else:\n            ctx.comment(dry_run_msg + msg.format(msg))\n\n    def dispense_while_moving(pip: InstrumentContext,\n                              well: Well, vol: float, steps: int,\n                              is_verbose: bool = False, pip_offset: float = 0):\n        \"\"\"\n        This function dispenses a partial volume = vol/steps and then moves\n        a distance/steps and repeats\n        \"\"\"\n        well_diameter = float(well.diameter)\n        dispense_distance = well_diameter - well_edge_offset\n        dy = dispense_distance/steps  # Move a fraction (=steps) of well diatr.\n        dv = vol/steps\n        start_location = well.bottom().move(\n            Point(0, well_diameter/2 - well_edge_offset, pip_offset))\n        pip.move_to(start_location)\n        for i in range(steps):\n            loc = start_location.move(Point(0, i*dy, 0))\n            if is_verbose:\n                ctx.comment(\"Dispensing at: {}\".format(loc))\n            pip.dispense(dv, loc)\n\n    # reagents\n    '''\n    Define where all reagents are on the deck using the labware defined above.\n\n    e.g.\n\n    water = reservoir12.wells()[-1]\n    waste = reservoir.wells()[0]\n    samples = plate.rows()[0][0]\n    dnase = tuberack.wells_by_name()['A4']\n\n    '''\n    # Each slide block has 8 \"wells\", each well uses up 100 uL of each\n    # reagent: Block, antibody1, antibody2, nuclear counterstain\n    block = VolTracker(tuberack, vol_reagent, start=1, end=4,\n                       msg=\"Refill Block reagent tubes\")\n    antibody1 = VolTracker(tuberack, vol_reagent, start=5, end=8,\n                           msg=\"Refill Antibody 1 reagent tubes\")\n    antibody2 = VolTracker(tuberack, vol_reagent, start=9, end=13,\n                           msg=\"Refill Antibody 2 reagent tubes\")\n    # Nuclear counterstain\n    nuc_cstn = VolTracker(tuberack, vol_reagent, start=14, end=17,\n                          msg=\"Refill Nuclear counterstain reagent tubes\")\n    pbs = VolTracker(\n        reservoir, 288*10**3, start=1, end=1, mode='reagent',\n        pip_type='single', msg=\"Refill PBS reservoir\")\n\n    # plate, tube rack maps\n    # Add all wells up to the block before the last block\n    # Assume that they all have 8 samples\n    target_wells = []\n    for slide_block in slide_blocks[:-1]:\n        for well in slide_block.wells():\n            target_wells.append(well)\n\n    # Add the wells of the last block, samples may be less than 8\n    for i in range(n_last_samples):\n        target_wells.append(slide_blocks[-1].wells()[i])\n\n    '''\n    Define any plate or tube maps here.\n\n    e.g.\n\n    plate_wells_by_row = [well for row in plate.rows() for well in row]\n\n    '''\n\n    # protocol\n\n    '''\n\n    Include header sections as follows for each \"section\" of your protocol.\n\n    Section can be defined as a step in a bench protocol.\n\n    e.g.\n\n    ctx.comment('\\n\\nMOVING MASTERMIX TO SAMPLES IN COLUMNS 1-6\\n')\n\n    for .... in ...:\n        ...\n        ...\n\n    ctx.comment('\\n\\nRUNNING THERMOCYCLER PROFILE\\n')\n\n    ...\n    ...\n    ...\n\n\n    '''\n    # Set the temperature to 4 degrees on the temperature module.\n    if temp_mod:\n        temp_mod.set_temperature(4)\n    dt = t_per_block * n_slots\n    reag_transfer_fn = multi_dispense_reagent_p1000 if is_multi_disp_reags \\\n        else single_dispense_reagent_p1000\n\n    # Transfer 100 \u00b5L of block from the tuberack to each destination well\n    # (slide) (could be done as a multi-dispense with the P1000)\n    # Measure time from the start of pipetting and subtract from 1 hr pause\n    # so that the next pipetting step starts after 1 hour and not 1 hour +\n    # the time it takes to finish the reagent transfer\n    if not is_start_after_1st_incbn:  # Skip 1st incubation?\n        ctx.comment(\"\\n\\nAdding block reagent\\n\")\n        reag_transfer_fn(block, target_wells, do_dry_run=is_dry_run,\n                         pip_offset=pipette_offset,\n                         steps=dispense_steps, do_reuse_tip=is_reuse_reag_tips)\n        # Pause/Incubate for 1 hour\n        if is_stop_after_1st_incbn:\n            ctx.comment(\"\\n\\nStopping protocol after 1st incubation\")\n            ctx.comment(\"Remove the slides, store them at 4C ON, \"\n                        + \"then replace the slides in the morning and restart \"\n                        + \"the protocol. (Remember to set the option to start \"\n                        + \"the protocol after the 1st incubation step)\")\n            return\n        pause(\"block\", time_elapsed_sec=dt, do_dry_run=is_dry_run)\n    else:\n        ctx.comment(\n            \"Starting the protocol from the 2nd reagent step (antibody1)\")\n    # Transfer 100 \u00b5L of primary antibody to dest. wells (slide)\n    ctx.comment(\"\\n\\nAdding Antibody 1 reagent\\n\")\n    reag_transfer_fn(antibody1, target_wells, do_dry_run=is_dry_run,\n                     pip_offset=pipette_offset,\n                     steps=dispense_steps, do_reuse_tip=is_reuse_reag_tips)\n    # Pause 1 hour\n    pause(\"Antibody 1\", time_elapsed_sec=dt, do_dry_run=is_dry_run)\n    # Transfer 4 mL of PBS to each slide target well (i.e. 4 round trips)\n    # with the P1000 (Slide wash)\n    ctx.comment(\"\\n\\nWashing slides with PBS\\n\")\n    wash(p1000, 4000, pbs, target_wells, do_dry_run=is_dry_run,\n         pip_offset=pipette_offset, steps=dispense_steps,\n         do_reuse_tip=is_reuse_wash_tips)\n    # Transfer 100 \u00b5L of the second antibody\n    ctx.comment(\"\\n\\nAdding Antibody 2 reagent\\n\")\n    reag_transfer_fn(antibody2, target_wells, do_dry_run=is_dry_run,\n                     pip_offset=pipette_offset,\n                     steps=dispense_steps, do_reuse_tip=is_reuse_reag_tips)\n    # Pause 1 hour\n    pause(\"Antibody 2\", time_elapsed_sec=dt, do_dry_run=is_dry_run)\n    # Wash slides with 4 mL of PBS\n    ctx.comment(\"\\n\\nWashing slides with PBS\\n\")\n    wash(p1000, 4000, pbs, target_wells, do_dry_run=is_dry_run,\n         pip_offset=pipette_offset, steps=dispense_steps,\n         do_reuse_tip=is_reuse_wash_tips)\n    # Transfer 100 \u00b5L nuclear counterstain to each well\n    ctx.comment(\"\\n\\nAdding Nuclear counterstain reagent\\n\")\n    reag_transfer_fn(nuc_cstn, target_wells, do_dry_run=is_dry_run,\n                     pip_offset=pipette_offset,\n                     steps=dispense_steps, do_reuse_tip=is_reuse_reag_tips)\n    # Incubate 5 minutes\n    pause(\"Nuclear counterstain\", pause_period_minutes=5,\n          do_dry_run=is_dry_run, time_elapsed_sec=dt)\n    # Wash slides with 4 mL of PBS\n    ctx.comment(\"\\n\\nWashing slides with PBS\\n\")\n    wash(p1000, 4000, pbs, target_wells, do_dry_run=is_dry_run,\n         pip_offset=pipette_offset, steps=dispense_steps,\n         do_reuse_tip=is_reuse_wash_tips)\n    ctx.comment(\"\\n\\n~~~~ End of protocol ~~~~\\n\")\n",
    "custom_labware_defs": [
        {
            "brand": {
                "brand": "customslideblock V2",
                "brandId": []
            },
            "cornerOffsetFromSlot": {
                "x": 0,
                "y": 0,
                "z": 0
            },
            "dimensions": {
                "xDimension": 127.5,
                "yDimension": 85.2,
                "zDimension": 102.9
            },
            "groups": [
                {
                    "metadata": {
                        "wellBottomShape": "flat"
                    },
                    "wells": [
                        "A1",
                        "B1",
                        "A2",
                        "B2",
                        "A3",
                        "B3",
                        "A4",
                        "B4"
                    ]
                }
            ],
            "metadata": {
                "displayCategory": "wellPlate",
                "displayName": "Customslideblock V2 8 Well Plate 20000 \u00b5L",
                "displayVolumeUnits": "\u00b5L",
                "tags": []
            },
            "namespace": "custom_beta",
            "ordering": [
                [
                    "A1",
                    "B1"
                ],
                [
                    "A2",
                    "B2"
                ],
                [
                    "A3",
                    "B3"
                ],
                [
                    "A4",
                    "B4"
                ]
            ],
            "parameters": {
                "format": "irregular",
                "isMagneticModuleCompatible": false,
                "isTiprack": false,
                "loadName": "customslideblockv2_8_wellplate",
                "quirks": []
            },
            "schemaVersion": 2,
            "version": 1,
            "wells": {
                "A1": {
                    "depth": 23.5,
                    "diameter": 10,
                    "shape": "circular",
                    "totalLiquidVolume": 20000,
                    "x": 13,
                    "y": 60.2,
                    "z": 79.4
                },
                "A2": {
                    "depth": 23.5,
                    "diameter": 10,
                    "shape": "circular",
                    "totalLiquidVolume": 20000,
                    "x": 38,
                    "y": 60.2,
                    "z": 79.4
                },
                "A3": {
                    "depth": 23.5,
                    "diameter": 10,
                    "shape": "circular",
                    "totalLiquidVolume": 20000,
                    "x": 63,
                    "y": 60.2,
                    "z": 79.4
                },
                "A4": {
                    "depth": 23.5,
                    "diameter": 10,
                    "shape": "circular",
                    "totalLiquidVolume": 20000,
                    "x": 88,
                    "y": 60.2,
                    "z": 79.4
                },
                "B1": {
                    "depth": 23.5,
                    "diameter": 10,
                    "shape": "circular",
                    "totalLiquidVolume": 20000,
                    "x": 13,
                    "y": 24.2,
                    "z": 79.4
                },
                "B2": {
                    "depth": 23.5,
                    "diameter": 10,
                    "shape": "circular",
                    "totalLiquidVolume": 20000,
                    "x": 38,
                    "y": 24.2,
                    "z": 79.4
                },
                "B3": {
                    "depth": 23.5,
                    "diameter": 10,
                    "shape": "circular",
                    "totalLiquidVolume": 20000,
                    "x": 63,
                    "y": 24.2,
                    "z": 79.4
                },
                "B4": {
                    "depth": 23.5,
                    "diameter": 10,
                    "shape": "circular",
                    "totalLiquidVolume": 20000,
                    "x": 88,
                    "y": 24.2,
                    "z": 79.4
                }
            }
        }
    ],
    "fields": [
        {
            "default": 8,
            "label": "Number of slide blocks",
            "name": "n_slots",
            "type": "int"
        },
        {
            "default": 8,
            "label": "Number of samples in the last block",
            "name": "n_last_samples",
            "type": "int"
        },
        {
            "default": 1500,
            "label": "Volume in reagent containers",
            "name": "vol_reagent",
            "type": "float"
        },
        {
            "default": 5,
            "label": "Sweep dispense steps",
            "name": "dispense_steps",
            "type": "int"
        },
        {
            "label": "Start protocol after 1st incubation step",
            "name": "is_start_after_1st_incbn",
            "options": [
                {
                    "label": "No",
                    "value": false
                },
                {
                    "label": "Yes",
                    "value": true
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Stop protocol after 1st incubation step",
            "name": "is_stop_after_1st_incbn",
            "options": [
                {
                    "label": "No",
                    "value": false
                },
                {
                    "label": "Yes",
                    "value": true
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Reagent tuberack",
            "name": "tuberack_lname",
            "options": [
                {
                    "label": "Opentrons 24 Tube Rack with NEST 1.5 mL Screwcap",
                    "value": "opentrons_24_tuberack_nest_1.5ml_screwcap"
                },
                {
                    "label": "Opentrons 24 Tube Rack with NEST 1.5 mL Snapcap",
                    "value": "opentrons_24_tuberack_nest_1.5ml_snapcap"
                },
                {
                    "label": "Opentrons 24 Tube Rack with Eppendorf 1.5 mL Safe-Lock Snapcap",
                    "value": "opentrons_24_tuberack_eppendorf_1.5ml_safelock_snapcap"
                },
                {
                    "label": "Opentrons 24 Tube Rack with Generic 2 mL Screwcap",
                    "value": "opentrons_24_tuberack_generic_2ml_screwcap"
                },
                {
                    "label": "Opentrons 24 Well Aluminum Block with NEST 2 mL Screwcap",
                    "value": "opentrons_24_aluminumblock_nest_2ml_screwcap"
                },
                {
                    "label": "Opentrons 24 Well Aluminum Block with NEST 0.5 mL Screwcap",
                    "value": "opentrons_24_aluminumblock_nest_0.5ml_screwcap"
                },
                {
                    "label": "Opentrons 24 Well Aluminum Block with NEST 1.5 mL Screwcap",
                    "value": "opentrons_24_aluminumblock_nest_1.5ml_screwcap"
                },
                {
                    "label": "Opentrons 24 Well Aluminum Block with NEST 1.5 mL Snapcap",
                    "value": "opentrons_24_aluminumblock_nest_1.5ml_snapcap"
                },
                {
                    "label": "Opentrons 24 Well Aluminum Block with NEST 2 mL Snapcap",
                    "value": "opentrons_24_aluminumblock_nest_2ml_snapcap"
                },
                {
                    "label": "Opentrons 24 Well Aluminum Block with Generic 2 mL Screwcap",
                    "value": "opentrons_24_aluminumblock_generic_2ml_screwcap"
                }
            ],
            "type": "dropDown"
        },
        {
            "default": 0.1,
            "label": "Pipette offset",
            "name": "pipette_offset",
            "type": "float"
        },
        {
            "label": "Do a dry run?",
            "name": "is_dry_run",
            "options": [
                {
                    "label": "No",
                    "value": false
                },
                {
                    "label": "Yes",
                    "value": true
                }
            ],
            "type": "dropDown"
        },
        {
            "default": 205,
            "label": "Time per block (s)",
            "name": "t_per_block",
            "type": "float"
        },
        {
            "label": "Multi-dispense reagents?",
            "name": "is_multi_disp_reags",
            "options": [
                {
                    "label": "Yes",
                    "value": true
                },
                {
                    "label": "No",
                    "value": false
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Reuse reagent tips?",
            "name": "is_reuse_reag_tips",
            "options": [
                {
                    "label": "Yes",
                    "value": true
                },
                {
                    "label": "No",
                    "value": false
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Reuse PBS wash tips?",
            "name": "is_reuse_wash_tips",
            "options": [
                {
                    "label": "Yes",
                    "value": true
                },
                {
                    "label": "No",
                    "value": false
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Use temperature module?",
            "name": "temp_mod_lname",
            "options": [
                {
                    "label": "Don't use the module",
                    "value": false
                },
                {
                    "label": "Use Temperature module GEN2",
                    "value": "temperature module gen2"
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "P1000 slot",
            "name": "p1000_slot",
            "options": [
                {
                    "label": "Left",
                    "value": "left"
                },
                {
                    "label": "Right",
                    "value": "right"
                }
            ],
            "type": "dropDown"
        },
        {
            "default": 1,
            "label": "Well edge offset (mm)",
            "name": "well_edge_offset",
            "type": "float"
        },
        {
            "label": "Use a custom slide block?",
            "name": "is_use_custom_block",
            "options": [
                {
                    "label": "No",
                    "value": false
                },
                {
                    "label": "Yes",
                    "value": true
                }
            ],
            "type": "dropDown"
        },
        {
            "default": "loadName goes here",
            "label": "Custom labware loadName",
            "name": "custom_labware_lname",
            "type": "str"
        }
    ],
    "instruments": [
        {
            "mount": "left",
            "name": "p1000_single_gen2"
        }
    ],
    "labware": [
        {
            "name": "Customslideblock V2 8 Well Plate 20000 \u00b5L on 1",
            "share": false,
            "slot": "1",
            "type": "customslideblockv2_8_wellplate"
        },
        {
            "name": "Agilent 1 Well Reservoir 290 mL on 2",
            "share": false,
            "slot": "2",
            "type": "agilent_1_reservoir_290ml"
        },
        {
            "name": "Opentrons 24 Tube Rack with NEST 1.5 mL Screwcap on 3",
            "share": false,
            "slot": "3",
            "type": "opentrons_24_tuberack_nest_1.5ml_screwcap"
        },
        {
            "name": "Customslideblock V2 8 Well Plate 20000 \u00b5L on 4",
            "share": false,
            "slot": "4",
            "type": "customslideblockv2_8_wellplate"
        },
        {
            "name": "Customslideblock V2 8 Well Plate 20000 \u00b5L on 5",
            "share": false,
            "slot": "5",
            "type": "customslideblockv2_8_wellplate"
        },
        {
            "name": "Opentrons 96 Tip Rack 1000 \u00b5L on 6",
            "share": false,
            "slot": "6",
            "type": "opentrons_96_tiprack_1000ul"
        },
        {
            "name": "Customslideblock V2 8 Well Plate 20000 \u00b5L on 7",
            "share": false,
            "slot": "7",
            "type": "customslideblockv2_8_wellplate"
        },
        {
            "name": "Customslideblock V2 8 Well Plate 20000 \u00b5L on 8",
            "share": false,
            "slot": "8",
            "type": "customslideblockv2_8_wellplate"
        },
        {
            "name": "Customslideblock V2 8 Well Plate 20000 \u00b5L on 9",
            "share": false,
            "slot": "9",
            "type": "customslideblockv2_8_wellplate"
        },
        {
            "name": "Customslideblock V2 8 Well Plate 20000 \u00b5L on 10",
            "share": false,
            "slot": "10",
            "type": "customslideblockv2_8_wellplate"
        },
        {
            "name": "Customslideblock V2 8 Well Plate 20000 \u00b5L on 11",
            "share": false,
            "slot": "11",
            "type": "customslideblockv2_8_wellplate"
        },
        {
            "name": "Opentrons Fixed Trash on 12",
            "share": false,
            "slot": "12",
            "type": "opentrons_1_trash_1100ml_fixed"
        }
    ],
    "metadata": {
        "apiLevel": "2.11",
        "author": "Eskil Andersen <protocols@opentrons.com>",
        "protocolName": "357404: Slide sample antibody staining",
        "source": "Custom Protocol Request"
    },
    "modules": []
}