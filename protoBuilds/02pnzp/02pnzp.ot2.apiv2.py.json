{
    "content": "\nmetadata = {\n    'author': 'Michael Fichtner <michael.fichtner@mdc-berlin.de>',\n    'description': 'The protocol is intended to prepare and run a PCR \\\n                    using the opentrons cycler module',\n    'apiLevel': '2.11'\n            }\n\n# For 50 ml falcons\nconical_volume = 3.27   # in ml\nheight_increase = 1.63   # mm per ml\n\n\ndef sorting_tips(pip):\n    '''This function will sort the tips in a tip box back to front. Useful if\n       if only a few tips have been used.\n       Takes roughly 20 min per box'''\n       \n    for rack in pip.tip_racks:\n        if rack.next_tip() and not rack.next_tip().well_name == \"A1\":\n            well_number = 0\n            while rack.next_tip():\n                pip.pick_up_tip()\n                pip.drop_tip(rack.wells()[well_number])\n                well_number += 1\n\ndef take_from_falcon(vol, tube, solution_vol, pip, rate=1):\n    '''Helper function to track changes of the volume in falcon tubes and\n    adjusts the height of the pipette accordingly.\n    Returns the remaining volume of a given liquid.'''\n    \n    if solution_vol > conical_volume:\n        aspirate_well = tube.bottom(z=((solution_vol/1000)*height_increase)-(vol/1000))\n    else:\n        aspirate_well = tube.bottom(z=2)\n    solution_vol -= vol\n    pip.aspirate(vol, aspirate_well, rate=rate)\n            \n    return solution_vol\n\ndef dispense_to_falcon(vol, tube, solution_vol, pip, rate=1, mix=False):\n    '''Helper function to track changes of the volume in falcon tubes and\n    adjusts the height of the pipette accordingly.\n    Returns the remaining volume of a given liquid.'''\n    \n    if solution_vol > conical_volume:\n        z_height = ((solution_vol / 1000) * height_increase) - (vol/1000)\n    else:\n        z_height = 2\n    \n    dispense_well = tube.bottom(z=z_height)\n    solution_vol += vol\n    pip.dispense(vol, dispense_well, rate=rate)\n    if mix:\n        pip.mix(15, 200, dispense_well.bottom(z=z_height), rate=rate)\n    return solution_vol\n\ndef transfer_to_tube(total_vol, source, source_vol, target, target_vol,\n                     pip, new_tip=True, rate=1):\n    pip.pick_up_tip()\n    while total_vol >= 220:\n        source_vol = take_from_falcon(200, source, source_vol, pip, rate)\n        target_vol = dispense_to_falcon(200, target, target_vol, pip)\n        total_vol -= 200\n        if new_tip:\n            pip.drop_tip()\n            pip.pick_up_tip()\n        \n    if total_vol <= 200:\n        source_vol = take_from_falcon(total_vol, source, source_vol, pip, rate)\n        target_vol = dispense_to_falcon(total_vol, target, target_vol, pip)\n        total_vol = 0\n    elif total_vol > 200 and total_vol < 220:\n        split_vol = total_vol / 2\n        source_vol = take_from_falcon(split_vol, source, source_vol, pip, rate)\n        target_vol = dispense_to_falcon(split_vol, target, target_vol, pip)\n        if new_tip:\n            pip.drop_tip()\n            pip.pick_up_tip()\n        source_vol = take_from_falcon(split_vol, source, source_vol, pip, rate)\n        target_vol = dispense_to_falcon(split_vol, target, target_vol, pip)\n        total_vol = 0\n    else:\n        raise ValueError(\"Wrong total volume. That should not happen! Please \\\n                         contact the protocol developer.\")\n    pip.blow_out()\n    pip.drop_tip()\n    \n    return source_vol, target_vol\n\ndef distribute_multiple(vol, source, targets: list, pip,\n                        new_tip=True, source_vol=200):\n    ''' The distribute() function has a bug that would cause contamination\n        of the source vial because it ignores the new_tip=always.\n        Thus I wrote my own. '''\n        \n    total_wells = len(targets)\n    if pip.max_volume == 300:   # That means p300\n        excess_vol = 0    \n        max_wells_per_step = (200 - excess_vol) // vol\n    elif pip.max_volume == 20:\n        excess_vol = 0\n        max_wells_per_step = (20 - excess_vol) // vol\n    else:\n        raise Exception(\"Cannot determine the type of pipette.\")\n    assert max_wells_per_step > 0, \"Volume per well is too large\" # TODO: make a fall back to transfer\n    \n    pip.pick_up_tip()\n    while total_wells > max_wells_per_step:\n        if (source_vol / 1000 ) > conical_volume:\n            z_height = ((source_vol / 1000) * height_increase) - (vol / 1000)\n        else:\n            z_height = 1\n        vol_needed = (max_wells_per_step * vol) + excess_vol\n        pip.aspirate(vol_needed, source.bottom(z=z_height))\n        for i in range(int(max_wells_per_step)):\n            pip.dispense(vol, targets.pop(0))\n        if new_tip:\n            pip.drop_tip()\n            pip.pick_up_tip()\n        total_wells -= max_wells_per_step\n        source_vol -= vol_needed\n    if total_wells > 0 and total_wells <= max_wells_per_step:\n        vol_needed = (total_wells * vol) + excess_vol\n        if (source_vol / 1000 ) > conical_volume:\n            z_height = ((source_vol / 1000) * height_increase) - (vol / 1000)\n        else:\n            z_height = 1\n        pip.aspirate(vol_needed, source.bottom(z=z_height))\n        for i in range(len(targets)):\n            pip.dispense(vol, targets.pop(0))\n        source_vol -= vol_needed\n    pip.drop_tip()\n    \n    return source_vol\n    \n    \ndef run(prot):\n    ############## Change variables here ##################\n    reaction_vol = 100     # total volume of PCR reaction per well (in ul)\n    sample_no = 9        # Number of different samples (excluding water) (1-12)\n    sample_vol = 1         # ul per PCR reaction \n    replicates = 3         # number of replicates per sample (1-95)\n    MM_no = 3              # Number of Mastermixes (1-3)\n    repetitions = 35 \n    cycler_profile = [{'temperature': 95, 'hold_time_seconds': 30},\n                      {'temperature': 60, 'hold_time_seconds': 30},\n                      {'temperature': 72, 'hold_time_seconds': 30}]\n    \n    ######## Hard coded values that you may want to change\n    sort_tips = True   # Sort the tips back to front at the end\n    fast = True        # If False: Performs homing steps in between, not needed anymore\n    init_denat_temp = 98 # degrees celsius for initial denaturation\n    init_denat_time = 120 # seconds for initial denaturation\n    \n    # Calculate amount needed per sample:\n    vol_Buffer = reaction_vol / 10\n    vol_Primers = reaction_vol / 20\n    vol_dNTPs = reaction_vol / 50\n    vol_Polymerase = reaction_vol / 100\n    vol_MgCl2 = reaction_vol / 50\n        \n    excess = 1.1          # Percentage of excess for MM\n    \n    ######## Do not change anything below here ############\n    ######## unless you know what you are doing ###########\n    #-----------------------------------------------------#\n\n    water_needed = reaction_vol - vol_Buffer - (vol_Primers * 2) - vol_dNTPs - \\\n                   vol_Polymerase - sample_vol - vol_MgCl2\n    wells_needed = (sample_no * replicates) + 1  # per mastermix, the +1 is for water control\n    assert wells_needed * MM_no <= 96, \"Not enough free wells for MM\"\n    assert water_needed >= 0, \"Reaction volume is too large\"\n    assert sample_no <= 12, \"Only 12 different samples are allowed at the moment.\"\n    \n    \n    tiprack_1_p300 = prot.load_labware('opentrons_96_filtertiprack_200ul', 2)\n    #tiprack_2_p300 = prot.load_labware('opentrons_96_filtertiprack_200ul', 5)\n    tiprack_1_p20 = prot.load_labware('opentrons_96_filtertiprack_20ul', 1)\n    \n    \n    tube_rack = prot.load_labware(\n        'opentrons_24_tuberack_eppendorf_1.5ml_safelock_snapcap', 6)\n    huge_tubes_rack = prot.load_labware(\n        'opentrons_10_tuberack_falcon_4x50ml_6x15ml_conical', 9)\n        \n    p300 = prot.load_instrument('p300_single_gen2', 'left',\n                                tip_racks=[tiprack_1_p300]) #, tiprack_2_p300])\n    p20 = prot.load_instrument('p20_single_gen2', 'right',\n                               tip_racks=[tiprack_1_p20])\n    \n    tempdeck = prot.load_module('temperature module gen2', '3')\n    cool_rack = tempdeck.load_labware('opentrons_24_aluminumblock_nest_1.5ml_screwcap')\n    \n    \n    cycler = prot.load_module('Thermocycler Module') # By default: Cylcer covers slots 7,8,10,11\n    pcr_plate = cycler.load_labware('opentrons_96_aluminumblock_nest_wellplate_100ul')\n    \n    water = huge_tubes_rack.wells_by_name()['A3']    \n    complete_MMs = [huge_tubes_rack.wells_by_name()['A4'],\n                    huge_tubes_rack.wells_by_name()['B3'],\n                    huge_tubes_rack.wells_by_name()['B4']\n                    ]\n   \n    dNTPs = cool_rack.wells_by_name()['A1']\n    polymerase = cool_rack.wells_by_name()['A6']\n    buffer = tube_rack.wells_by_name()['D1']        \n    mgcl2 = tube_rack.wells_by_name()['D2']\n    primers_fw = [tube_rack.wells_by_name()['A1'],\n                  tube_rack.wells_by_name()['A2'],\n                  tube_rack.wells_by_name()['A3']\n                  ]\n\n    primers_rev = [tube_rack.wells_by_name()['B1'],\n                  tube_rack.wells_by_name()['B2'],\n                  tube_rack.wells_by_name()['B3']\n                  ]\n    \n    assert MM_no <= len(complete_MMs), \"More MMs required than tubes available\"    \n    \n    sample_tubes = tube_rack.wells()[12:12+sample_no]\n        \n    total_water_needed = water_needed * wells_needed * MM_no * excess + sample_vol\n    total_buffer_needed = vol_Buffer * wells_needed * excess * MM_no\n    \n    ######### Protocol starts here ################\n    prot.comment(\"Water needed: \" + str(total_water_needed))\n    prot.comment(\"Buffer_needed: \" + str(total_buffer_needed))\n    prot.comment(\"Primer_needed (each): \" + str(vol_Primers * wells_needed * excess))\n    prot.comment(\"dNTPs needed: \" + str(vol_dNTPs * wells_needed * excess))\n    prot.comment(\"MgCl2 needed: \" + str(vol_MgCl2 * wells_needed * excess))\n    prot.comment(\"Polymerase needed: \" + str(vol_Polymerase * wells_needed * excess))\n\n    # will not wait until 4 degrees are reached\n    tempdeck.start_set_temperature(4)\n    cycler.set_block_temperature(4)\n    \n    # Preparing Mastermixes\n    for i in range(MM_no):\n        mastermix_volume = 0\n        # Transfer water -> I assume that we will never use less than 20 ul water\n        water_to_transfer = water_needed * wells_needed * excess\n        total_water_needed, mastermix_volume = transfer_to_tube(water_to_transfer,\n                                                                water, total_water_needed,\n                                                                complete_MMs[i], mastermix_volume,\n                                                                new_tip=False, pip=p300)\n        \n        # Transfer Buffer\n        buffer_to_transfer = vol_Buffer * wells_needed * excess\n        if buffer_to_transfer > 20:\n            pipette = p300\n        else:\n            pipette = p20\n        total_buffer_needed, mastermix_volume = transfer_to_tube(buffer_to_transfer,\n                                                                buffer, total_buffer_needed,\n                                                                complete_MMs[i], mastermix_volume,\n                                                                new_tip=True, pip=pipette)\n        \n        # Transfer Primers\n        primers_to_transfer = vol_Primers * wells_needed * excess\n        if primers_to_transfer > 20:\n            pipette = p300\n        else:\n            pipette = p20\n        _ , mastermix_volume = transfer_to_tube(primers_to_transfer,\n                                                primers_fw[i], primers_to_transfer,\n                                                complete_MMs[i], mastermix_volume,\n                                                new_tip=True, pip=pipette)\n        _ , mastermix_volume = transfer_to_tube(primers_to_transfer,\n                                                primers_rev[i], primers_to_transfer,\n                                                complete_MMs[i], mastermix_volume,\n                                                new_tip=True, pip=pipette)\n        \n        # Transfer dNTPs\n        dNTPs_to_transfer = vol_dNTPs * wells_needed * excess\n        if dNTPs_to_transfer > 20:\n            pipette = p300\n        else:\n            pipette = p20     \n        _ , mastermix_volume = transfer_to_tube(dNTPs_to_transfer,\n                                                dNTPs, dNTPs_to_transfer,\n                                                complete_MMs[i], mastermix_volume,\n                                                new_tip=True, pip=pipette)\n        \n        # Transfer MgCl2\n        if vol_MgCl2 > 0:\n            mgcl2_to_transfer = vol_MgCl2 * wells_needed * excess\n            if mgcl2_to_transfer > 20:\n                pipette = p300\n            else:\n                pipette = p20   \n            _ , mastermix_volume = transfer_to_tube(mgcl2_to_transfer,\n                                                    mgcl2, mgcl2_to_transfer,\n                                                    complete_MMs[i], mastermix_volume,\n                                                    new_tip=True, pip=pipette)\n        # Transfer Polymerase\n        polymerase_to_transfer = vol_Polymerase * wells_needed * excess\n        if polymerase_to_transfer > 20:\n            pipette = p300\n        else:\n            pipette = p20\n        _ , mastermix_volume = transfer_to_tube(polymerase_to_transfer,\n                                                polymerase, polymerase_to_transfer,\n                                                complete_MMs[i], mastermix_volume,\n                                                new_tip=True, pip=pipette)\n        \n        # Mixing\n        p300.pick_up_tip()\n        mixes = 10\n        for height in range(1,\n                            int((mastermix_volume / 1000) * height_increase) + 5,\n                            1):\n            p300.mix(mixes, 200, complete_MMs[i].bottom(z=height), rate=3)\n        p300.drop_tip()\n        \n    cycler.open_lid()\n    # I had the feeling the robot drifts a bit, hence the homing step.\n    if not fast:\n        prot.home()\n\n    # TODO: Check if below can be adjusted to make it easier to read\n    \n    # Transferring MM to plate   \n    \n    #Note: If more than 1 Master Mix is used the skip_wells variable helps to\n    #      make the final layout easier. If the samples + water are not\n    #      multipes of 8, the last wells will be left free so that the first\n    #      sample will always be in row A.\n      \n    skip_wells = 8 - (wells_needed % 8) # Needed to make an easier layout if multiple Mastermixes are used.\n    if skip_wells == 8: skip_wells = 0\n    for i in range(MM_no):\n        if reaction_vol > 20:\n            pipette = p300\n        else:\n            pipette = p20\n\n        mastermix_volume = distribute_multiple(reaction_vol-sample_vol, complete_MMs[i],\n                                               pcr_plate.wells()[i*wells_needed+(i*skip_wells):(1+i)*wells_needed+(i*skip_wells)],\n                                               pip=p300, new_tip=False,\n                                               source_vol=mastermix_volume)\n    \n    \n    # Transferring samples to plate\n    prot.comment(\"######### Transferring samples into Plate ###########\")\n    for MM in range(MM_no):\n        next_MM = (skip_wells + wells_needed) * MM\n        for j in range(sample_no):\n            distribute_multiple(sample_vol, sample_tubes[j],\n                                pcr_plate.wells()[next_MM+(j*replicates):next_MM+(j*replicates+replicates)],\n                                p20)\n\n        p20.distribute(\n            sample_vol, water, pcr_plate.wells()[next_MM+wells_needed - 1], \n            new_tip='always')\n    \n    # Mix each well\n    for MM in range(MM_no):\n        next_MM = (skip_wells + wells_needed) * MM\n        for j in range(sample_no):\n            p300.pick_up_tip()\n            for well in pcr_plate.wells()[next_MM+(j*replicates):next_MM+(j*replicates+replicates)]:\n                p300.mix(3, 60, well)\n            p300.drop_tip()\n\n    ############ Starting the cycler\n    cycler.set_lid_temperature(105)\n    cycler.close_lid()\n    \n    # Initial denaturation\n    cycler.set_block_temperature(init_denat_temp,\n                                 hold_time_seconds=init_denat_time,\n                                 block_max_volume=reaction_vol)\n    # Actual run\n    rep_split = int(repetitions / 5)\n    for i in range(rep_split):\n        # Since there is no way to tell at which cycle the PCR currently is,\n        # I print every 5 cycles a message to get an estimate how long is left.\n        cycler.execute_profile(steps=cycler_profile, repetitions=5,\n                           block_max_volume=reaction_vol)\n        prot.comment(\"Cycles completed: \" + str((i+1)*5))\n    \n    remaining_reps = repetitions % 5\n    if remaining_reps > 0:\n        cycler.execute_profile(steps=cycler_profile, repetitions=remaining_reps,\n                           block_max_volume=reaction_vol)\n        \n    # Final extension\n    cycler.set_block_temperature(72, hold_time_seconds=300,\n                                 block_max_volume=reaction_vol)\n    \n    cycler.set_block_temperature(4, block_max_volume=reaction_vol)\n    \n    ### Calcuating last required tips.\n    ### Specifically requested by our lab staff.\n    last_p20_tip = \"error\"\n    for rack in p20.tip_racks:\n        if rack.next_tip() and not rack.next_tip().well_name == \"A1\":\n            last_p20_tip = rack.next_tip()\n    last_p300_tip = \"error\"\n    for rack in p300.tip_racks:\n        if rack.next_tip() and not rack.next_tip().well_name == \"A1\":\n            last_p300_tip = rack.next_tip() \n            \n    if sort_tips:\n        sorting_tips(p20)\n        sorting_tips(p300)\n    \n    prot.comment(\"######### Last required tips ###########\")\n    prot.comment(\"P20: \" + str(last_p20_tip))\n    prot.comment(\"P300: \" + str(last_p300_tip))\n    \n    ",
    "custom_labware_defs": [],
    "fields": [],
    "instruments": [
        {
            "mount": "left",
            "name": "p300_single_gen2"
        },
        {
            "mount": "right",
            "name": "p20_single_gen2"
        }
    ],
    "labware": [
        {
            "name": "Opentrons 96 Filter Tip Rack 20 \u00b5L on 1",
            "share": false,
            "slot": "1",
            "type": "opentrons_96_filtertiprack_20ul"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 200 \u00b5L on 2",
            "share": false,
            "slot": "2",
            "type": "opentrons_96_filtertiprack_200ul"
        },
        {
            "name": "Opentrons 24 Well Aluminum Block with NEST 1.5 mL Screwcap on Temperature Module GEN2 on 3",
            "share": false,
            "slot": "3",
            "type": "opentrons_24_aluminumblock_nest_1.5ml_screwcap"
        },
        {
            "name": "Opentrons 24 Tube Rack with Eppendorf 1.5 mL Safe-Lock Snapcap on 6",
            "share": false,
            "slot": "6",
            "type": "opentrons_24_tuberack_eppendorf_1.5ml_safelock_snapcap"
        },
        {
            "name": "Opentrons 96 Well Aluminum Block with NEST Well Plate 100 \u00b5L on Thermocycler Module on 7",
            "share": false,
            "slot": "7",
            "type": "opentrons_96_aluminumblock_nest_wellplate_100ul"
        },
        {
            "name": "Opentrons 10 Tube Rack with Falcon 4x50 mL, 6x15 mL Conical on 9",
            "share": false,
            "slot": "9",
            "type": "opentrons_10_tuberack_falcon_4x50ml_6x15ml_conical"
        },
        {
            "name": "Opentrons Fixed Trash on 12",
            "share": false,
            "slot": "12",
            "type": "opentrons_1_trash_1100ml_fixed"
        }
    ],
    "metadata": {
        "apiLevel": "2.11",
        "author": "Michael Fichtner <michael.fichtner@mdc-berlin.de>",
        "description": "The protocol is intended to prepare and run a PCR                     using the opentrons cycler module"
    },
    "modules": [
        {
            "name": "TemperatureModuleContext at Temperature Module GEN2 on 3 lw Opentrons 24 Well Aluminum Block with NEST 1.5 mL Screwcap on Temperature Module GEN2 on 3",
            "share": false,
            "slot": "3",
            "type": "tempdeck"
        },
        {
            "name": "ThermocyclerContext at Thermocycler Module on 7 lw Opentrons 96 Well Aluminum Block with NEST Well Plate 100 \u00b5L on Thermocycler Module on 7",
            "share": false,
            "slot": "7",
            "type": "thermocycler"
        }
    ]
}