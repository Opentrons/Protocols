{
    "content": "from opentrons import protocol_api\nfrom opentrons.protocol_api.labware import Well\nimport re\nfrom collections import Counter\nfrom typing import Union, Sequence\nfrom math import pi\n\nmetadata = {\n    'protocolName': 'Advanced cherrypicking',\n    'author': 'Eskil Andersen <protocols@opentrons.com>',\n    'source': 'Custom Protocol Request',\n    'apiLevel': '2.11'\n}\n\n\ndef get_tube_liquid_level(\n        tube: Well,\n        volume: float) -> float:\n    radius = (tube.diameter/2) * 0.94\n    # 0.95 is a fudge factor because height seems too low\n    # for the actual tube volume marks given a volume\n    cone_height = 0.171 * tube.depth\n    liquid_height = 0\n\n    # Calculate the liquid height in the tube given its volume in mL\n    cone_max_vol = (pi*radius**2*cone_height)/3\n    # Case where the liquid height extends beyond the tube cone\n    if volume > cone_max_vol:\n        liquid_height = cone_height\n        # Calculate the height of the volume in the cylinder and add it up\n        volume -= cone_max_vol\n        cylinder_height = volume/(pi*radius**2)\n        liquid_height += cylinder_height\n        return liquid_height\n    else:  # Volume is only inside the cone\n        h_cone_calc = 3*volume/(pi*radius**2)\n        return h_cone_calc\n\n\ndef aspirate_liq_level(\n        pip,\n        initial_tube_volume: float,\n        aspiration_volume: float,\n        tube: Well,\n        tip_length: float) -> float:\n\n    liq_height = get_tube_liquid_level(tube, initial_tube_volume)\n    # Never aspirate below 1 mm offset\n    aspiration_height = round(max(1, liq_height-3/(4*tip_length)), 2)\n    aspiration_locn = tube.bottom(aspiration_height)\n    pip.aspirate(aspiration_volume, aspiration_locn)\n    return aspiration_height\n\n\ndef dispense_liq_level(\n        pip,\n        initial_tube_volume: float,\n        dispensing_volume: float,\n        tube: Well) -> float:\n    dispensing_height = get_tube_liquid_level(tube, initial_tube_volume)\n    dispensing_height += 10\n    dispensing_locn = tube.bottom(dispensing_height)\n    pip.dispense(dispensing_volume, dispensing_locn)\n    return dispensing_height\n\n\ndef get_instruction_param_val(\n        params_string: str, param_name: str, type: str) -> Union[\n        int, float, str]:\n    # Split the comma separated parameters string into individual parameters.\n    # Parameters are not case or leading/trailing whitespace sensitive\n    params_string = params_string.strip().lower()\n    params = params_string.split(',')\n    param = ''\n    # Look up the parameter/value pair e.g. pause=5m10s\n    for p in params:\n        if param_name in p:\n            param = p\n            break\n    # Return False if the parameter isn't in the instruction parameters\n    if param == '':\n        return False\n    # Check if there's a value associated with the parameter\n    if '=' in param:\n        if type == \"int\":\n            return int(param.split('=')[1])\n        elif type == \"float\":\n            return float(param.split('=')[1])\n        elif type == \"str\":\n            return param.split('=')[1]\n        else:\n            raise Exception(f\"Unrecognized type argument: {type}\")\n    # Raise an exception if there's no associated value with the parameter\n    else:\n        err_msg = \"There was no associated value with the parameter {}\"\n        err_msg = err_msg.format(param)\n        raise Exception(err_msg)\n\n\ndef reply_to_bool(reply_string: str) -> bool:\n    \"\"\" Takes a yes/no reply to a question in the form of a string and\n    returns a True/False boolean value or None for blank entries. None should\n    be treated as an implicit no generally, but it sometimes has special\n    meaning in the code, for example if a labware definition has a module\n    a blank response at some other point should not be interpreted as a\n    conflicting answer, but rather as a subordinate no that is overriden\n    by a yes at some other point.\n    \"\"\"\n\n    reply_string = reply_string.strip().lower()\n    if reply_string == \"yes\":\n        return True\n    if reply_string == \"no\":\n        return False\n    if reply_string == \"\":\n        return False\n    raise Exception(\n        \"Unrecognized reply, should be yes or no, or blank. \"\n        \"Blank responses are interpreted as 'no'\")\n\n\ndef read_var(input: str, var_type: str) -> Union[str, int, float]:\n    \"\"\"\n    Takes an input and checks if it is a blank string.\n    If the string is blank it is returned as is, otherwise\n    the function converts it to an int or a float depending on\n    the value of var_type. Returns a blank string if the input was a blank str.\n    \"\"\"\n\n    if input == '':\n        return ''\n\n    if var_type == \"int\":\n        try:\n            return int(input)\n        except ValueError:\n            err_msg = \"Error converting the input '{}' to an integer value\"\n            err_msg = err_msg.format(input)\n            raise ValueError(err_msg)\n\n    if var_type == \"float\":\n        try:\n            return float(input)\n        except ValueError:\n            err_msg = \"Error converting the input '{}' to a floating value\"\n            err_msg = err_msg.format(input)\n            raise ValueError(err_msg)\n\n    err_msg = f\"Unrecognized variable type argument: {var_type}\"\n    raise Exception(err_msg)\n\n\ndef run(ctx: protocol_api.ProtocolContext):\n\n    [transfer_csv,\n     left_mount_pipette_type,\n     right_mount_pipette_type,\n     left_tip_type,\n     right_tip_type,\n     left_pip_tiprack_slots,\n     right_pip_tiprack_slots,\n     tip_reusage_strategy] = get_values(  # noqa: F821\n     \"transfer_csv\",\n     \"left_mount_pipette_type\",\n     \"right_mount_pipette_type\",\n     \"left_tip_type\",\n     \"right_tip_type\",\n     \"left_pip_tiprack_slots\",\n     \"right_pip_tiprack_slots\",\n     \"tip_reusage_strategy\")\n\n    tiprack_map = {\n        'p20_single_gen2': {\n            'standard': 'opentrons_96_tiprack_20ul',\n            'filter': 'opentrons_96_filtertiprack_20ul'\n        },\n        'p300_single_gen2': {\n            'standard': 'opentrons_96_tiprack_300ul',\n            'filter': 'opentrons_96_filtertiprack_200ul'\n        },\n        'p1000_single_gen2': {\n            'standard': 'opentrons_96_tiprack_1000ul',\n            'filter': 'opentrons_96_filtertiprack_1000ul'\n        }\n    }\n\n    # Tiprack parameter validation e.g. \"1, 5, 8, 11\"\n    # Any whitespace in the string is removed before the comparison\n    valid_tiprack_string_regex = re.compile(\n        r\"^(10|11|[1-9])(,(10|11|[1-9]))*$\")\n    # regex for matching all kinds of whitespace\n    whitespace_re = re.compile(r\"\\s+\")\n    # Validate tiprack strings, and create list of tiprack slots\n    left_tiprack_slot_list, right_tiprack_slot_list = [], []\n    for mount, tiprack_string, slot_list in zip(\n            [\"left\", \"right\"],\n            [left_pip_tiprack_slots, right_pip_tiprack_slots],\n            [left_tiprack_slot_list, right_tiprack_slot_list]):\n        # Remove all whitespaces in the tiprack parameter string\n        tiprack_string_no_ws = re.sub(whitespace_re, '', tiprack_string)\n        # Check format validity\n        if valid_tiprack_string_regex.match(tiprack_string_no_ws) is None:\n            msg = (\"The {} pipette tiprack slot list format is invalid, a \"\n                   \"valid specification uses comma separated integers between \"\n                   \"1-11 e.g. \\\"5, 6, 7\\\", your string was \\\"{}\\\"\")\n            msg = msg.format(mount, tiprack_string)\n            raise Exception(msg)\n        # Create a list of tiprack slots\n        for slot in tiprack_string_no_ws.split(','):\n            slot_list.append(int(slot))\n        # Check for duplicates in the list\n        if max(Counter(slot_list).values()) > 1:\n            msg = \"There are duplicates in the {} pipette tiprack slot list {}\"\n            msg = msg.format(mount, tiprack_string)\n            raise Exception(msg)\n\n    # Check for overlap between left and right tiprack slot lists\n    # by taking the set intersection (&: Set intersection operator)\n    intersection = set(left_tiprack_slot_list) & set(right_tiprack_slot_list)\n    if len(intersection) > 0:\n        msg = (\"There are overlaps between your left and right pipette \"\n               \"tiprack slots in position(s) {}\")\n        msg = msg.format(intersection)\n        raise Exception(msg)\n\n    # Load the CSV\n    # ENUMERATED HEADERS:\n    # 0. step_id, 1. instruction, 2. instruction_parameters, 3. source_labware,\n    # 4. magnetic_module,5. temperature_module, 6. source_slot, 7. source_well,\n    # 8. source_well_starting_volume, 9. transfer_volume, 10. air_gap_volume,\n    # 11. dest_labware, 12. dest_magnetic_module, 13. dest_temperature_module,\n    # 14. dest_slot, 15. dest_well, 16. dest_well_starting_volume,\n    # 17. touch_tip, 18. blow_out\n    csv_rows = transfer_csv.split(\"\\n\")\n    csv_list = []\n    # Remove any empty lines in the CSV.\n    for i, row in enumerate(csv_rows):\n        if row == '':\n            del(csv_rows[i])\n        else:\n            csv_list.append(row.split(','))\n\n    slot_dict = {}\n    for i in range(1, 12):\n        slot_dict[i] = []\n\n    instruction_rows = []\n    # A well formed well index consists of a letter (A-P) and a number 1-24\n    # (because the largest standard labware is the 384 well plate whose indices\n    # go from A1 to P24)\n    # Regex: Match from the start of the string, then a letter from A to P\n    # followed by 0 or 1 instances of [1-2] followed by a number between 0-9,\n    # followed by the end of the string.\n    correct_well_index_regex = re.compile(r\"^[A-P][1-2]?[0-9]$\")\n    for row in csv_list[1:]:\n        step_id = read_var(row[0], \"int\")\n        instruction = row[1].strip().lower()\n        instruction_parameters = row[2].strip().lower()\n        source_lw = row[3].strip().lower()\n        # column 4 and 5 are read below in the `try:` sections\n        # 4: is_source_magmod\n        # 5: is_source_tempmod\n        source_slot = read_var(row[6], \"int\")\n        source_well = row[7].strip().upper()\n        source_well_starting_volume = read_var(row[8], \"float\")\n        if source_well_starting_volume == '':\n            source_well_starting_volume = 0\n        transfer_volume = read_var(row[9], \"float\")\n        air_gap_volume = read_var(row[10], \"float\")\n        if air_gap_volume == '':\n            air_gap_volume = 0\n        dest_lw = row[11]\n        # 12. and 13. loaded below (yes/no) type\n        # 12. is_dest_magmod\n        # 13. is_dest_tempmod\n        dest_slot = read_var(row[14], \"int\")\n        dest_well = row[15].strip().upper()\n        dest_well_starting_volume = read_var(row[16], \"float\")\n        # 17., 18., loaded below, yes/no type\n\n        # Check that the well indices are well formed:\n        for well_index, designation in zip(\n                [source_well, dest_well],\n                [\"source\", \"destination\"]):\n            match = correct_well_index_regex.match(well_index)\n            if not match and well_index != '':\n                err_msg = (\"The {} well {} index for step_id {} is \"\n                           \"invalid. It should start with a letter from A to \"\n                           \"P followed by a number between 1 to 24, e.g. B8\")\n                err_msg = err_msg.format(\n                    designation, source_well, step_id)\n                raise Exception(err_msg)\n\n        # Check that the slots are valid:\n        for slot, designation in zip(\n                [source_slot, dest_slot],\n                [\"source\", \"destination\"]):\n            if slot != '' and not (0 < slot < 12):\n                err_msg = (\"The {} labware slot ({}) for step_id {} is \"\n                           \"invalid. It should be a number from 1 to 11\")\n                err_msg = err_msg.format(\n                    designation, slot, step_id)\n                raise Exception(err_msg)\n\n        # Read the module loading choices (columm 4, 5, 12, and 13)\n        try:\n            is_source_magmod = reply_to_bool(row[4])\n            is_source_tempmod = reply_to_bool(row[5])\n        except Exception:\n            err_msg = (\"Step id {}: Unrecognized option for the source \"\n                       \"labware modules. Valid options are 'yes' or 'no' \"\n                       \"or a blank entry\")\n            err_msg = err_msg.format(step_id)\n            raise Exception(err_msg)\n        try:\n            is_dest_magmod = reply_to_bool(row[12])\n            is_dest_tempmod = reply_to_bool(row[13])\n        except Exception:\n            err_msg = (\"Step id {}: Unrecognized option for the destination \"\n                       \"labware modules. Valid options are 'yes' or 'no'. \"\n                       \"Please correct your CSV file.\")\n            err_msg = err_msg.format(step_id)\n            raise Exception(err_msg)\n\n        # Create an entry for the given slots labware and add it to slot_dict\n        for slot, labware, magmod, tmod in zip(\n                [source_slot, dest_slot],\n                [source_lw, dest_lw],\n                [is_source_magmod, is_dest_magmod],\n                [is_source_tempmod, is_dest_tempmod]):\n\n            if type(slot) is int:  # slot could be a blank string, should skip.\n                slot_dict[slot].append((step_id, labware, magmod, tmod))\n        try:\n            is_touch_tip = reply_to_bool(row[17])\n            is_blowout = reply_to_bool(row[18])\n        except Exception:\n            err_msg = (\"Step id {}: Unrecognized option for touch tip and/or \"\n                       \"blow out options. Valid options are 'yes' or 'no', \"\n                       \"or a blank value. Please correct your CSV file.\")\n            err_msg = err_msg.format(step_id)\n            raise Exception(err_msg)\n\n        # Check for error where both temperature and magnetic modules are\n        # loaded for the same labware/slot.\n        for is_magmod, is_tempmod, type_string in zip(\n                [is_source_magmod, is_dest_magmod],\n                [is_source_tempmod, is_dest_tempmod],\n                [\"source\", \"destination\"]):\n            if is_magmod and is_tempmod:\n                err_msg = (\"Error in {} labware module options with \"\n                           \"step_id {}: \" \"You cannot use both a magnetic \"\n                           \"module and a temperature module with the same \"\n                           \"labware/slot, please inspect your CSV file.\")\n                err_msg = err_msg.format(type_string, step_id)\n                raise Exception(err_msg)\n\n        # Check that labware used with the temperature module uses alum. blocks\n        for is_tempmod, labware, type_string in zip(\n                [is_source_tempmod, is_dest_tempmod],\n                [source_lw, dest_lw],\n                [\"Source\", \"Destination\"]):\n            if is_tempmod and \"aluminum\" not in labware:\n                err_msg = (\"Step id {}: {} labware must be of an aluminum \"\n                           \"block type to be used with a temperature module\")\n                err_msg = err_msg.format(step_id, type_string)\n                raise Exception(err_msg)\n\n        # Make sure the well indices are well formed\n        for well_index in zip(\n                [source_well, dest_well],\n                [\"source\", \"destination\"]):\n            pass\n\n        instruction_rows.append(\n            (step_id,  # 0\n             instruction,  # 1\n             instruction_parameters,  # 2\n             source_lw,  # 3\n             is_source_magmod,  # 4\n             is_source_tempmod,  # 5\n             source_slot,  # 6\n             source_well,  # 7\n             source_well_starting_volume,  # 8\n             transfer_volume,  # 9\n             air_gap_volume,  # 10\n             dest_lw,  # 11\n             is_dest_magmod,  # 12\n             is_dest_tempmod,  # 13\n             dest_slot,  # 14\n             dest_well,  # 15\n             dest_well_starting_volume,  # 16\n             is_touch_tip,  # 17\n             is_blowout  # 18\n             ))\n\n    # Check that the step_ids are continous\n    last_step_id = instruction_rows[0][0]\n    # Save the first step id so we can convert from step_id to list index\n    # later\n    first_step_id = last_step_id\n    if first_step_id < 0:\n        raise Exception(\n            \"Negative step id:s are reserved, please inspect your CSV\")\n    # Skip the first row, last_step_id is already set and we don't want to\n    # compare it to itself\n    for row in instruction_rows[1:]:\n        id = row[0]\n        if not id == last_step_id + 1:\n            err_msg = \"Discontinuity in step id:s between step_id {} and {}\"\n            err_msg = err_msg.format(last_step_id, id)\n            raise Exception(err_msg)\n        last_step_id = id\n\n    def step_id_to_index(step_id: int) -> int:\n        \"\"\"Converts a given step id to an index in the instruction_rows list\n        \"\"\"\n\n        nonlocal first_step_id\n        return step_id - first_step_id\n\n    # Check that there are no mismatching entries in the labware definitions\n    # Algorithm:\n    # 1. Add the tiprack entries to the slot dicts as well\n    # 2. Go through the dictionary entry for each slot in slots_dict and:\n    # 3. Treat the first labware entry as canon and require that it is well\n    # formed. It should have a labware API name, a slot, and should give\n    # complete answers about what modules it is using and not using.\n    # 4. Compare the 'canonical' definition to the subseqent ones for that slot\n    # 5. If the the subst. defns. are identical continue looping\n    # 6. If they are not: Raise an error and point out what the conflicting\n    # step_id:s are, (unless it's a conflict with a tiprack which don't have\n    # step_id:s), what labware API names, which slot\n    # After the canonical entry is properly entered\n    # it is allowed to specify only the slot as long\n    # as the other fields are just blank strings ('').\n    # 7. If there are no mismatching data the labware and tipracks\n    # can be loaded.\n\n    # Implementation\n    # 1.1 Add the  pipette tipracks to their respective slot lists\n    left_tips_lname = False\n    if left_mount_pipette_type:\n        left_tips_lname = tiprack_map[\n            left_mount_pipette_type][left_tip_type]\n        for slot in left_tiprack_slot_list:\n            slot_dict[slot].append((-1, left_tips_lname, \"left_mount\"))\n\n    right_tips_lname = False\n    if right_mount_pipette_type:\n        right_tips_lname = tiprack_map[\n            right_mount_pipette_type][right_tip_type]\n        for slot in right_tiprack_slot_list:\n            slot_dict[slot].append((-1, right_tips_lname, \"right_mount\"))\n\n    # 2. Iterate over the dictionary entries\n    for slot in slot_dict.keys():\n        # Check for cases where there's no labware definitions for the slot\n        # and continue to the next slot.\n        if len(slot_dict[slot]) == 0:\n            continue\n        # Skip tipracks (they are given step_id=-1):\n        if slot_dict[slot][0][0] == -1:\n            continue\n        # Canonical labware entry, must be well formed\n        canonical_lw_entry = slot_dict[slot][0]\n        canonical_step_id = canonical_lw_entry[0]\n        canonical_lw_name = canonical_lw_entry[1]\n        canonical_magmod = canonical_lw_entry[2]\n        canonical_tempmod = canonical_lw_entry[3]\n\n        # Check that the canonical entry is well defined\n        if canonical_lw_name == '' or canonical_magmod is None \\\n                or canonical_tempmod is None:\n            err_msg = (\"The initial labware definition for slot {} on the \"\n                       \"row with step_id {} is not well defined. It must \"\n                       \"include the labware API name and definite yes/no \"\n                       \"answers to the questions asking whether they are \"\n                       \"using either the Magnetic- or the Temperature module. \"\n                       \"Please inspect your CSV file.\")\n            err_msg = err_msg.format(slot, canonical_step_id)\n            raise Exception(err_msg)\n\n        for lw_entry in slot_dict[slot][1:]:\n\n            entry_step_id = lw_entry[0]\n            entry_lw_name = lw_entry[1]\n            entry_magmod = lw_entry[2]\n            entry_tempmod = lw_entry[3]\n            slot\n\n            if canonical_lw_name != entry_lw_name and entry_lw_name != '':\n                err_msg = (\"There is a mismatch between the labware API names \"\n                           \"for slot {}, the initial labware API name was {} \"\n                           \"and it was defined in the row with step_id {} \"\n                           \"but there is a mismatching API name ({}) on the \"\n                           \"row with step_id {}. Please inspect your CSV.\")\n                err_msg = err_msg.format(\n                    slot, canonical_lw_name, canonical_step_id,\n                    entry_lw_name, entry_step_id)\n                raise Exception(err_msg)\n\n            # Check for magnetic module setting mismatches\n            if canonical_magmod != entry_magmod and entry_magmod is not None:\n                err_msg = (\"There is a mismatch between the Magnetic module \"\n                           \"setting for {} on slot {} on the row with \"\n                           \"step_id {}, and the Magnetic module setting on \"\n                           \"the row with step id {}. Please inspect your \"\n                           \"CSV input file.\")\n                err_msg = err_msg.format(\n                    canonical_lw_name, slot, canonical_step_id, entry_step_id)\n\n            # Check for Temperature module setting mismatches\n            if canonical_tempmod != entry_tempmod \\\n                    and entry_tempmod is not None:\n                err_msg = (\"There is a mismatch between the Temperature \"\n                           \"module setting for {} on slot {} on the row with \"\n                           \"step_id {}, and the Temperature module setting on \"\n                           \"the row with step id {}. Please inspect your \"\n                           \"CSV input file.\")\n                err_msg = err_msg.format(\n                    canonical_lw_name, slot, canonical_step_id, entry_step_id)\n\n    # Check that 'dispense parked tip operations' are well formed. This means:\n    # 1. Not attempting to dispense an already dispensed parked tip\n    # 2. There must be minimally complete instructions for dispensing the tip\n    # meaning: dispensing volume, destination- slot and well.\n    # 3. dispense_parked_tip instructions must refer to step_id:s of\n    # aspirate_and_park_tip instructions\n\n    # 1. Check that all step_id instruction_rows for selecting a parked tip are\n    # unique\n    dispense_parked_tip_step_id_list = []\n    for instruction in instruction_rows:\n        disp_step_id = instruction[0]\n        if instruction[1] == 'dispense_parked_tip':\n            # Fetch the reference to the instruction where the tip was parked\n            # earlier\n            parking_instruction_id = get_instruction_param_val(\n                instruction[2], \"step_id\", \"int\")\n            dispense_parked_tip_step_id_list.append(parking_instruction_id)\n            # 3rd point Make sure the fetched step_id refers to an\n            # instruction to and aspirate_and_park_tip instruction.\n            trial_park_instrn_row = instruction_rows[\n                step_id_to_index(parking_instruction_id)]\n            possible_park_instrn = trial_park_instrn_row[1]\n            if possible_park_instrn != \"aspirate_and_park_tip\":\n                err_msg = (\"The dispense_parked_tip instruction with step \"\n                           \"id {} refers to step_id {} which is not an \"\n                           \"aspirate_and_park_tip instruction, \"\n                           \"inspect your CSV\")\n                err_msg = err_msg.format(disp_step_id, parking_instruction_id)\n                raise Exception(err_msg)\n\n            # For 2: check the presence of the parameters\n            # transfer_volume index: 9\n            # Destination slot: 14\n            # Destination well: 15\n            transfer_vol = instruction[9]\n            dest_slot = instruction[14]\n            dest_well = instruction[15]\n            for val, designation in zip(\n                    [transfer_vol, dest_slot, dest_well],\n                    [\"transfer volume\", \"destination slot\",\n                     \"destination well\"]):\n                if val == '':\n                    err_msg = (\"The {} value is blank for the \"\n                               \"dispense_parked_tip instruction with \"\n                               \"step_id {}.\")\n                    err_msg = err_msg.format(designation, disp_step_id)\n                    raise Exception(err_msg)\n\n    # For point 1: Count the occurences of each step_id, make sure there\n    # are only singular references so no double dispenses are tried.\n    step_id_occurences = Counter(dispense_parked_tip_step_id_list)\n    # Check the length of the list first, there might not be any entries\n    if len(dispense_parked_tip_step_id_list) > 0 \\\n            and max(step_id_occurences.values()) > 1:\n        err_msg = (\"There are multiples references to the same step_id for \"\n                   \"dispensing a parked tip. Can't dispense an already \"\n                   \"dispensed tip. Please inspect your input CSV file.\")\n        raise Exception(err_msg)\n\n    # Check 'aspirate_and_park_tip' instructions for validity\n    # A complete instruction must include the following (besides the\n    # instruction name which is aspirate_and_park_tip):\n    # 1. A source slot 2. A source well. 3. An aspiration volume (and a step\n    # id but step_id:s are validated elsewhere)\n    for instruction in instruction_rows:\n        asp_step_id = instruction[0]\n        if instruction[1] == 'aspirate_and_park_tip':\n\n            # Check the presence of the required parametere\n            # transfer_volume index: 9\n            # Source slot: 6\n            # Source well: 7\n            transfer_vol = instruction[9]\n            source_slot = instruction[6]\n            source_well = instruction[7]\n            for val, designation in zip(\n                    [transfer_vol, source_slot, source_well],\n                    [\"transfer volume\", \"source slot\",\n                     \"source well\"]):\n                if val == '':\n                    err_msg = (\"The {} value is blank for the \"\n                               \"aspirate_and_park_tip instruction \"\n                               \"with step_id {}.\")\n                    err_msg = err_msg.format(designation, asp_step_id)\n                    raise Exception(err_msg)\n\n    # Check well-formness of pause entries\n    # Pause entries need to match at least one unit of time entry, i.e.\n    # hours, minutes or seconds.\n    hour_match_regex = re.compile(r\"[0-9]+\\.?[0-9]*h\")\n    minute_match_regex = re.compile(r\"[0-9]+\\.?[0-9]*m\")\n    second_match_regex = re.compile(r\"[0-9]+\\.?[0-9]*s\")\n    for instruction in instruction_rows:\n        if instruction[1] == 'pause':\n            pause_step_id = instruction[0]\n            pause_time_str = get_instruction_param_val(\n                instruction[2], \"time\", \"str\")\n            if pause_time_str is False:\n                err_msg = (\"Could not find an associated pause time \"\n                           \"instruction parameter for the pause instruction \"\n                           \"with step_id {}. Please inspect your CSV input. \"\n                           \"A Proper instruction parameter is e.g. \"\n                           \"time=5m30s or time=1h10m\")\n                err_msg = err_msg.format(pause_step_id)\n                raise Exception(err_msg)\n            hour_match = hour_match_regex.search(pause_time_str)\n            minute_match = minute_match_regex.search(pause_time_str)\n            second_match = second_match_regex.search(pause_time_str)\n            if not hour_match and not minute_match and not second_match:\n                err_msg = (\"The pause instruction parameter for step_id {} \"\n                           \"does not seem to define a pause time. \"\n                           \"The instruction was {}. The proper format is \"\n                           \"some combination of [<x>h][<y>m][<z>s] \"\n                           \"e.g. '5m30s' or '10s' or '1h10m30s'\")\n                err_msg = err_msg.format(\n                    pause_step_id, pause_time_str)\n\n    # Check the transfer instructions for validity\n    # A valid transfer instruction must minimally consist of\n    # 1,2. A source slot and well, 3: A transfer volume, 4,5 A destination slot\n    # and a destination well.\n    for instruction in instruction_rows:\n        asp_step_id = instruction[0]\n        if instruction[1] == 'transfer':\n\n            # Check the presence of the required parametere\n            # transfer_volume index: 9\n            # Source slot: 6\n            # Source well: 7\n            # Destination slot: 14\n            # Destination well: 15\n            dest_slot = instruction[14]\n            transfer_vol = instruction[9]\n            source_slot = instruction[6]\n            source_well = instruction[7]\n            for val, designation in zip(\n                    [transfer_vol, source_slot, source_well],\n                    [\"transfer volume\", \"source slot\",\n                     \"source well\"]):\n                if val == '':\n                    err_msg = (\"The {} value is blank for the \"\n                               \"transfer instruction \"\n                               \"with step_id {}.\")\n                    err_msg = err_msg.format(designation, asp_step_id)\n                    raise Exception(err_msg)\n\n    temp_mods = {}\n    mag_mods = {}\n\n    # load labware and tipracks from the slot_dict entries\n    labware_dict = {}\n    labware_dict[\"left_mount\"] = {}\n    labware_dict[\"right_mount\"] = {}\n    labware_dict[\"labware\"] = {}\n    for slot_number, entry in zip(slot_dict.keys(), slot_dict.values()):\n        if len(entry) > 0:  # Skip empty deck slots\n            # Tiprack identifier is step_id==-1, load the tiprack in the entry\n            first_entry = entry[0]\n            if first_entry[0] == -1:\n                tiprack_lname = first_entry[1]\n                mount = first_entry[2]\n                tiprack = ctx.load_labware(tiprack_lname, slot_number)\n                labware_dict[mount][slot_number] = tiprack\n            # Load on a Magnetic module?\n            elif first_entry[2] is True:\n                mag_mod = ctx.load_module('magnetic module gen2', slot_number)\n                mag_mods[slot_number] = mag_mod\n                labware_lname = first_entry[1]\n                labware = mag_mod.load_labware(labware_lname)\n                labware_dict[\"labware\"][slot_number] = labware\n            # Load on Temperature module?\n            elif first_entry[3] is True:\n                temp_mod = ctx.load_module(\n                    'temperature module gen2', slot_number)\n                temp_mods[slot_number] = temp_mod\n                labware_lname = first_entry[1]\n                labware = temp_mod.load_labware(labware_lname)\n                labware_dict[\"labware\"][slot_number] = labware\n            # Load directly on the deck\n            else:\n                labware_lname = first_entry[1]\n                labware = ctx.load_labware(labware_lname, slot_number)\n                labware_dict[\"labware\"][slot_number] = labware\n\n    # Calculate final volumes for all wells, raise an Exception if the\n    # operations in the CSV results in filling any well more than 80 % of\n    # the max volume\n    # Algoritm:\n    # Read the transfer volume, destination well, and destination slot for\n    # The transfer instructions, and the dispense pipette tip instructions.\n    # When a new slot/well combo is encountered add it as a tuple key to a\n    # dictionary. Before adding any combinations the dictionary is checked\n    # to see if there's already an entry.\n    # If there is not an entry: Use the starting volume as the value for the\n    # key entry+the transfer volume.\n    # If there is already an entry: Add the transfer volume to the entry\n    # For each change of the entry check the entry against being above\n    # 80 % of the well max volume. The dictionary contains a class with two\n    # fields: current volume and max volume and a function to check itself\n    # for overflows (is_overflow())\n\n    class OverflowTracker:\n        def __init__(self, well_max_vol, current_vol):\n            self.well_max_vol = well_max_vol\n            self.current_vol = current_vol\n\n        def is_overflow(self) -> bool:\n            return True if \\\n                self.current_vol > 0.8 * self.well_max_vol else False\n\n        def add_vol(self, vol):\n            self.current_vol += vol\n\n    well_dict = {}\n    overflow_list = []\n    for instruction in instruction_rows:\n        step_id = instruction[0]\n        instr = instruction[1]\n        if instr == \"transfer\" or instruction == \"dispense_parked_tip\":\n            step_id = instruction[0]\n            dest_slot = instruction[14]\n            dest_well = instruction[15]\n            transfer_volume = instruction[9]\n            init_dest_well_vol = instruction[16]\n            # Check if the tuple of (slot, well) is already in the dict.\n            # otherwise create the entry\n            entry: OverflowTracker = well_dict.get((dest_slot, dest_well))\n            labware = labware_dict[\"labware\"][dest_slot]\n            try:\n                well: Well = labware.wells_by_name()[dest_well]\n            except KeyError:\n                err_msg = (f\"Could not retrieve well {dest_well} on {labware}.\"\n                           \" Does such a well exist on your labware?\")\n                raise Exception(err_msg)\n            if entry:\n                entry.add_vol(transfer_vol)\n            else:\n                # Retrieve the labware and get the max well volume\n                current_vol = transfer_vol\n                if init_dest_well_vol != '':\n                    current_vol += init_dest_well_vol\n                well_dict[(dest_slot, dest_well)] = \\\n                    OverflowTracker(well.max_volume, current_vol)\n\n            # Check if there is overflow, if so add the step at which overflow\n            # occurs and add it to a list\n            entry: OverflowTracker = well_dict[(dest_slot, dest_well)]\n            # Overflow entry: A tuple of step_id, slot, well, the max well vol\n            # and the current volume\n            if entry.is_overflow():\n                overflow_list.append((\n                    step_id,  # 0\n                    dest_well,  # 1\n                    dest_slot,  # 2\n                    entry.current_vol,  # 3\n                    entry.well_max_vol))  # 4\n\n    # Loop through the overflow entries and report errors\n    if len(overflow_list) > 0:\n        msg = \"\\n\"\n        for entry in overflow_list:\n            msg = (msg +\n                   f\"Step ID {entry[0]}: Overflow in well {entry[1]} on slot \"\n                   f\"{entry[2]}, executing this step would cause the total \"\n                   f\"volume to be {entry[3]} uL, while the well's 80 % of max \"\n                   f\"volume is {0.8*entry[4]} uL\\n\")\n\n    # load pipette(s)\n    left_tipracks_dict_vals = labware_dict[\"left_mount\"].values()\n    right_tipracks_dict_vals = labware_dict[\"right_mount\"].values()\n    left_tipracks = [rack for rack in left_tipracks_dict_vals]\n    right_tipracks = [rack for rack in right_tipracks_dict_vals]\n    pip_left = False\n    pip_right = False\n    if left_mount_pipette_type:\n        pip_left = ctx.load_instrument(\n          left_mount_pipette_type, \"left\", tip_racks=left_tipracks)\n    if right_mount_pipette_type:\n        pip_right = ctx.load_instrument(\n          right_mount_pipette_type, \"right\", tip_racks=right_tipracks)\n\n    # Save the tip lengths for liquid height tracking/offset aspiration:\n    tip_length_dict = {}\n    if pip_left:\n        tip_length_dict[pip_left] = left_tipracks[0].tip_length\n    if pip_right:\n        tip_length_dict[pip_right] = right_tipracks[0].tip_length\n\n    def pick_up(pipette, is_reuse_tip):\n        \"\"\"`pick_up()` will pause the protocol when all tip boxes are out of\n        tips, prompting the user to replace all tip racks. Once tipracks are\n        reset, the protocol will start picking up tips from the first tip\n        box as defined in the slot order when assigning the labware definition\n        for that tip box. `pick_up()` will track tips for both pipettes if\n        applicable.\n\n        :param pipette: The pipette desired to pick up tip\n        as definited earlier in the protocol (e.g. p300, m20).\n        \"\"\"\n        if is_reuse_tip and pipette.has_tip:\n            return\n        try:\n            pipette.pick_up_tip()\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Replace empty tip racks\")\n            pipette.reset_tipracks()\n            pipette.pick_up_tip()\n\n    def drop_tip(pip, is_reuse_tip):\n        \"\"\"\n        Drops the tip unless the strategy is to reuse the same tip.\n        \"\"\"\n        if is_reuse_tip is True:\n            return\n        else:\n            pip.drop_tip()\n\n    def select_pip(volume, is_single_action=False):\n        \"\"\" Returns the correct pipette for the transfer and its max volume\n        :param volume: The (total) volume to use the pipette with\n        :param is_single_action: True if the aspiration/dispense should be\n        completed with a single aspiration or dispense (i.e. no splitting up\n        of the operations into smaller volumes is allowed). Used for aspirate\n        and park operations.\n        \"\"\"\n        nonlocal pip_left, pip_right, left_mount_pipette_type\n        nonlocal right_mount_pipette_type, left_tip_type, right_tip_type\n\n        # Aspirate and park tip pipette selection\n        if is_single_action:\n            if volume < 20.01:\n                if pip_left and \"20\" in left_mount_pipette_type:\n                    return pip_left, 20\n                elif pip_right and \"20\" in right_mount_pipette_type:\n                    return pip_right, 20\n                else:\n                    raise Exception(\n                        (\"There is no 20 uL pipette loaded for aspirating and \"\n                         f\"parking a volume of {volume} uL\"))\n            elif volume < 200.01:\n                if pip_left and \"300\" in left_mount_pipette_type:\n                    max_vol = 200 if left_tip_type == \"filter\" else 300\n                    return pip_left, max_vol\n                elif pip_right and \"300\" in right_mount_pipette_type:\n                    max_vol = 200 if right_tip_type == \"filter\" else 300\n                    return pip_right, max_vol\n                else:\n                    raise Exception(\n                        (\"There is no 300 uL pipette loaded for aspirating \"\n                         f\"and parking a volume of {volume} uL\"))\n            elif volume < 300.01:\n                if pip_left and \"300\" in left_mount_pipette_type \\\n                        and left_tip_type == \"standard\":\n                    return pip_left, 300\n                elif pip_right and \"300\" in right_mount_pipette_type \\\n                        and right_tip_type == \"standard\":\n                    return pip_right, 300\n                else:\n                    raise Exception(\n                        (\"There is no 300 uL pipette loaded for aspirating \"\n                         f\"and parking a volume of {volume} uL\"))\n            elif volume < 1000.01:\n                if pip_left and \"1000\" in left_mount_pipette_type:\n                    return pip_left, 1000\n                elif pip_right and \"1000\" in right_mount_pipette_type:\n                    return pip_right, 1000\n                else:\n                    raise Exception(\n                        (\"There is no 1000 uL pipette loaded for handling a \"\n                         f\"transfer volume of {volume} uL\"))\n            else:\n                raise Exception(\n                    \"Cannot aspirate and park a tip for an aspiration \"\n                    f\"volume of {volume}\")\n\n        if volume < 100.01:\n            if pip_left and \"20\" in left_mount_pipette_type:\n                return pip_left, 20\n            elif pip_right and \"20\" in right_mount_pipette_type:\n                return pip_right, 20\n            elif pip_left and \"300\" in left_mount_pipette_type:\n                max_vol = 200 if left_tip_type == \"filter\" else 300\n                return pip_left, max_vol\n            elif pip_right and \"300\" in right_mount_pipette_type:\n                max_vol = 200 if right_tip_type == \"filter\" else 300\n                return pip_right, max_vol\n            else:\n                raise Exception(\n                    (\"There is no 20 uL pipette loaded for handling a \"\n                     f\"transfer volume of {volume} uL\"))\n        elif volume < 1000.01:\n            if pip_left and \"300\" in left_mount_pipette_type:\n                max_vol = 200 if left_tip_type == \"filter\" else 300\n                return pip_left, max_vol\n            elif pip_right and \"300\" in right_mount_pipette_type:\n                max_vol = 200 if right_tip_type == \"filter\" else 300\n                return pip_right, max_vol\n            elif pip_right and \"1000\" in right_mount_pipette_type:\n                return pip_right, 1000\n            elif pip_left and \"1000\" in left_mount_pipette_type:\n                return pip_left, 1000\n            else:\n                raise Exception(\n                    (\"There is no 300 uL pipette loaded for handling a \"\n                     f\"transfer volume of {volume} uL\"))\n        else:\n            if pip_left and \"1000\" in left_mount_pipette_type:\n                return pip_left, 1000\n            elif pip_right and \"1000\" in right_mount_pipette_type:\n                return pip_right, 1000\n            else:\n                raise Exception(\n                    (\"There is no 1000 uL pipette loaded for handling a \"\n                     f\"transfer volume of {volume} uL\"))\n\n    tube_volume_track_dict = {}\n    tube_regex = re.compile(r\"(15|50)ml_conical\")\n\n    def track_tubes_liq_lvl(\n            lnames: Sequence[str],\n            wells: Sequence[Well],\n            initial_volumes: Sequence[float],\n            transfer_vol: float):\n        # Liquid level tracking for 15/15mL conicals\n        nonlocal tube_regex, tube_volume_track_dict\n        is_source_tube = False\n        is_dest_tube = False\n        for lname, well, init_vol, is_source in zip(\n                lnames, wells, initial_volumes, [True, False]):\n            # Not all instructions will have both a source and a destination lw\n            if not lname or lname == '':\n                continue\n            if tube_regex.search(lname):  # Match for 15/50 mL conicals\n                # Store the well (key) and volume value pair\n                # If the entry doesn't exist yet set the volume to\n                # the initial volume +/- the transfer volume, that is\n                # subtract if the well is a source, and add if it's a\n                # destination.\n                if is_source:\n                    is_source_tube = True\n                else:\n                    is_dest_tube = True\n                volume_change = -transfer_vol if is_source else \\\n                    transfer_vol\n                if tube_volume_track_dict.get(well):\n                    tube_volume_track_dict[well] += volume_change\n                else:\n                    # The dictionary entry doesn't exist because this is\n                    # the first time we encountered this tube during\n                    # execution.\n                    tube_volume_track_dict[well] \\\n                        = init_vol + volume_change\n        return is_source_tube, is_dest_tube\n\n    # --- PROTOCOL EXECUTION STARTS HERE ---\n    # Loop through the instructions and execute them\n    parked_tip_dict = {}\n    # Add slot, well tuples as keys and the well volume as the value when\n    # carrying out operations involving tubes. Use the value for liquid height\n    # tracking\n    #\n    for instruction in instruction_rows:\n        step_id = instruction[0]\n        instr = instruction[1]\n        # Transfer instruction algorithm:\n        # The source slot/well data [6,7] in the instruction is retrieves\n        # The well to aspirate from, and the destination slot/well is used to\n        # find what well to dispense into. Transfer volume informs how much vol\n        # to aspirate and dispense.\n        # The other parameters that matter are\n        # step id [0]: Report what step is being done. air_gap_volume [10],\n        # touch_tip [17] and blow_out [18]\n\n        if instr == \"transfer\":\n            source_slot = instruction[6]\n            source_well = instruction[7]\n            transfer_vol = instruction[9]\n            source_initial_well_vol = instruction[8]\n            air_gap_volume = instruction[10]\n            dest_slot = instruction[14]\n            dest_well = instruction[15]\n            dest_initial_well_vol = instruction[16]\n            is_touch_tip = instruction[17]\n            is_blowout = instruction[18]\n\n            # Retrieve the source and destn. labware and their wells:\n            source_lw = labware_dict[\"labware\"][source_slot]\n            source_well = source_lw.wells_by_name()[source_well]\n            dest_lw = labware_dict[\"labware\"][dest_slot]\n            dest_well = dest_lw.wells_by_name()[dest_well]\n            source_lw_lname = source_lw.load_name\n            dest_lw_lname = dest_lw.load_name\n            is_source_tube = False\n            is_dest_tube = False\n\n            is_source_tube, is_dest_tube = track_tubes_liq_lvl(\n                lnames=[source_lw_lname, dest_lw_lname],\n                wells=[source_well, dest_well],\n                initial_volumes=[\n                    source_initial_well_vol, dest_initial_well_vol],\n                transfer_vol=transfer_vol)\n\n            ctx.comment(\n                f\"\\n\\nExecuting transfer instruction with step_id {step_id}\\n\")\n\n            try:\n                pip, max_pip_vol = select_pip(transfer_vol)\n            except Exception:\n                raise Exception(\n                    f\"Error in executing instruction at step_id {step_id}\")\n            ctx.comment(f\"Selected the {pip} for the transfer\")\n            max_asp_vol = max_pip_vol - air_gap_volume\n\n            pick_up(pip, tip_reusage_strategy)\n            while transfer_vol > 0:\n                aspiration_vol = min(transfer_vol, max_asp_vol)\n                if is_source_tube:\n                    height = aspirate_liq_level(\n                        pip=pip,\n                        initial_tube_volume=tube_volume_track_dict[\n                            source_well],\n                        aspiration_volume=aspiration_vol,\n                        tube=source_well,\n                        tip_length=tip_length_dict[pip])\n                    ctx.comment(\n                        f\"Aspirated from tube {source_well} \"\n                        f\"at a height offset of {height} mm\")\n                else:\n                    pip.aspirate(aspiration_vol, source_well)\n                if air_gap_volume > 0:\n                    pip.air_gap(air_gap_volume)\n                if is_dest_tube:\n                    disp_height = dispense_liq_level(\n                        pip=pip,\n                        initial_tube_volume=tube_volume_track_dict[\n                            dest_well],\n                        dispensing_volume=aspiration_vol+air_gap_volume,\n                        tube=dest_well)\n                    ctx.comment(\n                        f\"Dispensed {aspiration_vol} uL to tube {dest_well} \"\n                        f\"at a height offset of {disp_height} mm\")\n                else:\n                    pip.dispense(aspiration_vol+air_gap_volume, dest_well)\n                if is_touch_tip:\n                    pip.touch_tip()\n                if is_blowout:\n                    pip.blow_out()\n                transfer_vol -= aspiration_vol\n            drop_tip(pip, tip_reusage_strategy)\n\n        elif instr == \"aspirate_and_park_tip\":\n            ctx.comment(\n                \"\\n\\nExecuting 'aspirate and park tip' instruction with \"\n                f\"step_id {step_id}\\n\")\n            source_slot = instruction[6]\n            source_well = instruction[7]\n            source_initial_well_vol = instruction[8]\n            transfer_vol = instruction[9]\n            air_gap_volume = instruction[10]\n            is_touch_tip = instruction[17]\n            is_blowout = instruction[18]\n            source_lw_lname = source_lw.load_name\n            is_source_tube = False\n\n            # Retrieve wells:\n            source_lw = labware_dict[\"labware\"][source_slot]\n            source_well = source_lw.wells_by_name()[source_well]\n\n            # Check if tubes are involved and track liquid levels:\n            track_tubes_liq_lvl(\n                lnames=[source_lw_lname, None],\n                wells=[source_well, None],\n                initial_volumes=[source_initial_well_vol, 0],\n                transfer_vol=[transfer_vol])\n\n            pip, _ = select_pip(\n                transfer_vol+air_gap_volume,\n                is_single_action=True)\n            ctx.comment(f\"Selected the {pip} for the aspiration\")\n            pick_up(pip, tip_reusage_strategy)\n            tip_parking_well = pip._last_tip_picked_up_from\n            # Save the well where the tip was parked as well as the tip used\n            # so that the protocol knows how to dispense it later.\n            parked_tip_dict[step_id] = tip_parking_well, pip\n            if is_source_tube:\n                asp_height = aspirate_liq_level(\n                    pip=pip,\n                    initial_tube_volume=tube_volume_track_dict[\n                        source_well],\n                    aspiration_volume=transfer_vol,\n                    tube=source_well,\n                    tip_length=tip_length_dict[pip])\n                tube_volume_track_dict[source_well] -= aspiration_vol\n                ctx.comment(\n                    f\"Aspirated {transfer_vol} uL from tube {source_well} \"\n                    f\"at a height offset of {asp_height} mm\")\n            else:\n                pip.aspirate(transfer_vol, source_well)\n            if air_gap_volume > 0:\n                pip.air_gap(air_gap_volume)\n            pip.return_tip()\n\n        elif instr == \"dispense_parked_tip\":\n            ctx.comment(\n                \"\\n\\nExecuting 'dispense parked tip' instruction with \"\n                f\"step_id {step_id}\\n\")\n            # Retrieve the step id for the action where the tip was parked\n            aspiration_and_park_step_id = get_instruction_param_val(\n                instruction[2], \"step_id\", \"int\")\n            parked_tip_well, pip = parked_tip_dict[aspiration_and_park_step_id]\n            ctx.comment(\n                f\"Selected the {pip} for the pick up parked tip and dispense\")\n            transfer_vol = instruction[9]\n            air_gap_volume = instruction[10]\n            dest_slot = instruction[14]\n            dest_well = instruction[15]\n            dest_initial_well_vol = instruction[16]\n            is_touch_tip = instruction[17]\n            is_blowout = instruction[18]\n\n            # Retrieve target well:\n            dest_lw = labware_dict[\"labware\"][dest_slot]\n            dest_well = dest_lw.wells_by_name()[dest_well]\n            dest_lw_lname = dest_lw.load_name\n            is_dest_tube = False\n\n            # Check if the target well is a tube and track liquid height if so\n            _, is_dest_tube = track_tubes_liq_lvl(\n                lnames=[None, dest_lw_lname],\n                wells=[None, dest_well],\n                initial_volumes=[0, dest_initial_well_vol],\n                transfer_vol=transfer_vol)\n\n            if pip.has_tip:\n                pip.drop_tip()\n            pip.pick_up_tip(parked_tip_well)\n            if is_dest_tube:\n                disp_height = dispense_liq_level(\n                    pip=pip,\n                    initial_tube_volume=tube_volume_track_dict[\n                        dest_well],\n                    dispensing_volume=transfer_vol+air_gap_volume,\n                    tube=dest_well)\n                ctx.comment(\n                    f\"Dispensed {transfer_vol} uL to tube {dest_well} \"\n                    f\"at a height offset of {disp_height} mm\")\n            else:\n                pip.dispense(transfer_vol+air_gap_volume, dest_well)\n            drop_tip(pip, tip_reusage_strategy)\n        elif instr == \"pause\":\n            ctx.comment(\n                f\"\\n\\nExecuting pause instruction with step_id {step_id}\")\n            time_param = get_instruction_param_val(\n                instruction[2],\n                \"time\",\n                \"str\")\n            hour_match = hour_match_regex.search(time_param)\n            minute_match = minute_match_regex.search(time_param)\n            second_match = second_match_regex.search(time_param)\n            hours = 0\n            minutes = 0\n            seconds = 0\n            # Decompose the time parameter into hours,\n            minutes and seconds\n            if hour_match:\n                hours = float(time_param[\n                    hour_match.start():hour_match.end()-1])\n            if minute_match:\n                minutes = float(\n                    time_param[minute_match.start():minute_match.end()-1])\n            if second_match:\n                seconds = float(\n                    time_param[second_match.start():second_match.end()-1])\n            ctx.delay(minutes=minutes+hours*60, seconds=seconds)\n        else:\n            raise Exception(\n                f\"Unrecognized instruction '{instr}' with step_id {step_id}\")\n    # import pdb; pdb.set_trace()\n    ctx.comment(\"\\n\\n~~~ Protocol finished ~~~\\n\")\n",
    "custom_labware_defs": [],
    "fields": [
        {
            "default": " step_id,instruction,instruction_parameters,source_labware,source_magnetic_module,source_temperature_module,source_slot,source_well,Source_well_starting_volume,transfer_volume,air_gap_volume,dest_labware,dest_magnetic_module,dest_temperature_module,dest_slot,dest_well,dest_well_starting_volume,touch_tip,blow_out\n1,transfer,,nest_96_wellplate_2ml_deep,yes,no,1,A1,2000,1000,50,corning_6_wellplate_16.8ml_flat,no,no,3,A1,0,no,no\n2,transfer,,corning_384_wellplate_112ul_flat,no,no,2,B1,100,100,10,nest_12_reservoir_15ml,no,no,4,A2,10,yes,yes\n3,aspirate_and_park_tip,,corning_384_wellplate_112ul_flat,no,no,2,C1,100,50,10,,,,,,,,\n4,pause,time=5m30s,,,,,,,,,,,,,,,,\n5,transfer,,corning_384_wellplate_112ul_flat,no,no,2,D1,100,60,0,corning_6_wellplate_16.8ml_flat,no,no,3,B2,10,yes,yes\n6,dispense_parked_tip,step_id=3,,,,,,,60,,corning_6_wellplate_16.8ml_flat,,,3,A2,,yes,yes\n7,transfer,,opentrons_24_aluminumblock_nest_2ml_screwcap,no,yes,6,A1,100,400,0,corning_6_wellplate_16.8ml_flat,no,no,3,B3,0,yes,Yes\n8,transfer,,opentrons_10_tuberack_falcon_4x50ml_6x15ml_conical,no,no,7,A1,10000,500,0,opentrons_10_tuberack_falcon_4x50ml_6x15ml_conical,no,no,7,A3,20000,Yes,yes\n9,transfer,,opentrons_10_tuberack_falcon_4x50ml_6x15ml_conical,no,no,7,A4,20000,500,,opentrons_10_tuberack_falcon_4x50ml_6x15ml_conical,no,no,7,A3,,,",
            "label": "Transfer .csv File",
            "name": "transfer_csv",
            "type": "textFile"
        },
        {
            "label": "Pipette type in the left mount",
            "name": "left_mount_pipette_type",
            "options": [
                {
                    "label": "P300 Single (GEN 2)",
                    "value": "p300_single_gen2"
                },
                {
                    "label": "P20 Single (GEN 2)",
                    "value": "p20_single_gen2"
                },
                {
                    "label": "P1000 Single (GEN 2)",
                    "value": "p1000_single_gen2"
                },
                {
                    "label": "None",
                    "value": false
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Pipette type in the right mount",
            "name": "right_mount_pipette_type",
            "options": [
                {
                    "label": "P1000 Single (GEN 2)",
                    "value": "p1000_single_gen2"
                },
                {
                    "label": "P300 Single (GEN 2)",
                    "value": "p300_single_gen2"
                },
                {
                    "label": "P20 Single (GEN 2)",
                    "value": "p20_single_gen2"
                },
                {
                    "label": "None",
                    "value": false
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Tip type for the left pipette",
            "name": "left_tip_type",
            "options": [
                {
                    "label": "standard",
                    "value": "standard"
                },
                {
                    "label": "filter",
                    "value": "filter"
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Tip type for the right pipette",
            "name": "right_tip_type",
            "options": [
                {
                    "label": "standard",
                    "value": "standard"
                },
                {
                    "label": "filter",
                    "value": "filter"
                }
            ],
            "type": "dropDown"
        },
        {
            "default": "10,11",
            "label": "Left pipette tiprack slots",
            "name": "left_pip_tiprack_slots",
            "type": "str"
        },
        {
            "default": "5,8",
            "label": "Right pipette tiprack slots",
            "name": "right_pip_tiprack_slots",
            "type": "str"
        },
        {
            "label": "Reuse the same tip throughout?",
            "name": "tip_reusage_strategy",
            "options": [
                {
                    "label": "No",
                    "value": false
                },
                {
                    "label": "Yes",
                    "value": true
                }
            ],
            "type": "dropDown"
        }
    ],
    "instruments": [
        {
            "mount": "left",
            "name": "p300_single_gen2"
        },
        {
            "mount": "right",
            "name": "p1000_single_gen2"
        }
    ],
    "labware": [
        {
            "name": "NEST 96 Deepwell Plate 2mL on Magnetic Module GEN2 on 1",
            "share": false,
            "slot": "1",
            "type": "nest_96_wellplate_2ml_deep"
        },
        {
            "name": "Corning 384 Well Plate 112 \u00b5L Flat on 2",
            "share": false,
            "slot": "2",
            "type": "corning_384_wellplate_112ul_flat"
        },
        {
            "name": "Corning 6 Well Plate 16.8 mL Flat on 3",
            "share": false,
            "slot": "3",
            "type": "corning_6_wellplate_16.8ml_flat"
        },
        {
            "name": "NEST 12 Well Reservoir 15 mL on 4",
            "share": false,
            "slot": "4",
            "type": "nest_12_reservoir_15ml"
        },
        {
            "name": "Opentrons 96 Tip Rack 1000 \u00b5L on 5",
            "share": false,
            "slot": "5",
            "type": "opentrons_96_tiprack_1000ul"
        },
        {
            "name": "Opentrons 24 Well Aluminum Block with NEST 2 mL Screwcap on Temperature Module GEN2 on 6",
            "share": false,
            "slot": "6",
            "type": "opentrons_24_aluminumblock_nest_2ml_screwcap"
        },
        {
            "name": "Opentrons 10 Tube Rack with Falcon 4x50 mL, 6x15 mL Conical on 7",
            "share": false,
            "slot": "7",
            "type": "opentrons_10_tuberack_falcon_4x50ml_6x15ml_conical"
        },
        {
            "name": "Opentrons 96 Tip Rack 1000 \u00b5L on 8",
            "share": false,
            "slot": "8",
            "type": "opentrons_96_tiprack_1000ul"
        },
        {
            "name": "Opentrons 96 Tip Rack 300 \u00b5L on 10",
            "share": false,
            "slot": "10",
            "type": "opentrons_96_tiprack_300ul"
        },
        {
            "name": "Opentrons 96 Tip Rack 300 \u00b5L on 11",
            "share": false,
            "slot": "11",
            "type": "opentrons_96_tiprack_300ul"
        },
        {
            "name": "Opentrons Fixed Trash on 12",
            "share": false,
            "slot": "12",
            "type": "opentrons_1_trash_1100ml_fixed"
        }
    ],
    "metadata": {
        "apiLevel": "2.11",
        "author": "Eskil Andersen <protocols@opentrons.com>",
        "protocolName": "Advanced cherrypicking",
        "source": "Custom Protocol Request"
    },
    "modules": [
        {
            "name": "MagneticModuleContext at Magnetic Module GEN2 on 1 lw NEST 96 Deepwell Plate 2mL on Magnetic Module GEN2 on 1",
            "share": false,
            "slot": "1",
            "type": "magdeck"
        },
        {
            "name": "TemperatureModuleContext at Temperature Module GEN2 on 6 lw Opentrons 24 Well Aluminum Block with NEST 2 mL Screwcap on Temperature Module GEN2 on 6",
            "share": false,
            "slot": "6",
            "type": "tempdeck"
        }
    ]
}