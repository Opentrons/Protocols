{
    "content": "import math\nfrom opentrons import protocol_api\nfrom opentrons.protocol_api.contexts import InstrumentContext\n\nmetadata = {\n    'protocolName': 'Generic PCR Prep Part 2 - Mastermix and DNA Distribution',\n    'author': 'Opentrons <protocols@opentrons.com>',\n    'source': 'Protocol Library',\n    'apiLevel': '2.11'\n    }\n\n\ndef get_values(*names):\n    import json\n    _all_values = json.loads(\"\"\"{\n                                  \"n_samples\":96,\n                                  \"n_mixes\":0,\n                                  \"aspiration_rate_multiplier\":1,\n                                  \"dispensation_rate_multiplier\":1,\n                                  \"left_pipette_lname\":false,\n                                  \"right_pipette_lname\":\"p20_multi_gen2\",\n                                  \"use_filter_tips_left\":true,\n                                  \"use_filter_tips_right\":true,\n                                  \"mastermix_volume\":18,\n                                  \"DNA_volume\":2,\n                                  \"mastermix_reservoir_lname\":\"nest_12_reservoir_15ml\",\n                                  \"DNA_well_plate_lname\":\"opentrons_96_aluminumblock_nest_wellplate_100ul\",\n                                  \"destination_well_plate_lname\":\"opentrons_96_aluminumblock_nest_wellplate_100ul\",\n                                  \"DNA_well_plate_tmod\":\"temperature module gen2\",\n                                  \"dest_well_plate_tmod\":\"temperature module gen2\"\n                                  }\n                                  \"\"\")\n    return [_all_values[n] for n in names]\n\n\ndef run(ctx: protocol_api.ProtocolContext):\n\n    [n_samples,\n     n_mixes,\n     aspiration_rate_multiplier,\n     dispensation_rate_multiplier,\n     left_pipette_lname,\n     right_pipette_lname,\n     use_filter_tips_left,\n     use_filter_tips_right,\n     mastermix_volume,\n     DNA_volume,\n     mastermix_reservoir_lname,\n     DNA_well_plate_lname,\n     destination_well_plate_lname,\n     DNA_well_plate_tmod,\n     dest_well_plate_tmod] = get_values(  # noqa: F821\n     \"n_samples\",\n     \"n_mixes\",\n     \"aspiration_rate_multiplier\",\n     \"dispensation_rate_multiplier\",\n     \"left_pipette_lname\",\n     \"right_pipette_lname\",\n     \"use_filter_tips_left\",\n     \"use_filter_tips_right\",\n     \"mastermix_volume\",\n     \"DNA_volume\",\n     \"mastermix_reservoir_lname\",\n     \"DNA_well_plate_lname\",\n     \"destination_well_plate_lname\",\n     \"DNA_well_plate_tmod\",\n     \"dest_well_plate_tmod\")\n\n    # Error checking --------------------------------------------------------\n    if not left_pipette_lname and not right_pipette_lname:\n        raise Exception('You have to select at least 1 pipette.')\n\n    if not (DNA_volume > 0 or mastermix_volume > 0):\n        raise Exception(\"DNA or mastermix volume is 0 or less \u00b5L, please \"\n                        \"re-examine your volume parameters\")\n\n    if \"aluminum\" not in destination_well_plate_lname and dest_well_plate_tmod:\n        raise Exception(\"The destination plate must be loaded on an \"\n                        \"aluminum block in order to be used with a \"\n                        \"temperature module\")\n\n    if \"aluminum\" not in DNA_well_plate_lname and DNA_well_plate_tmod:\n        raise Exception(\"The DNA template plate must be loaded on an \"\n                        \"aluminum block in order to be used with a \"\n                        \"temperature module\")\n\n    assert aspiration_rate_multiplier > 0, \\\n        \"The aspiration flow-rate multiplier must be greater than zero\"\n\n    assert dispensation_rate_multiplier > 0, \\\n        \"The dispensation flow-rate multiplier must be greater than zero\"\n\n    assert n_samples > 0, \"There must be at least one sample\"\n    # Error checking on n_samples <= number of wells on destination plate\n    # is at the beginning of the protocol code because it requires loading\n    # the plates.\n    # The code is copied here for reference:\n    \"\"\"\n    if n_wells_dest < n_samples:\n        raise Exception(\"The destination plate does not have enough wells ({})\"\n                        \"for all the samples ({}). Check your number of \"\n                        \"samples parameter\".\n                        format(n_wells_dest, n_samples))\n    \"\"\"\n\n    assert left_pipette_lname or right_pipette_lname, \\\n        \"Load at least one pipette\"\n\n    # End error checking ---------------------------------------------------\n\n    mastermix_resv_slot = '3'\n    dest_plate_slot = '6'\n    tiprack_l_slots = ['4', '7']\n    tiprack_r_slots = ['5', '8']\n    DNA_plate_slots = ['9', '1', '2', '11']\n    n_plates = math.ceil(n_samples/96)\n\n    # load modules\n    '''\n\n    Add your modules here with:\n\n    module_name = ctx.load_module('{module_loadname}', '{slot number}')\n\n    Note : if you are loading a thermocycler, you do not need to specify\n    a slot number - thermocyclers will always occupy slots 7, 8, 10, and 11.\n\n    For all other modules, you can load them on slots 1, 3, 4, 6, 7, 9, 10.\n\n    '''\n\n    tmod_list = []\n    for tmod_lname, slot in zip([DNA_well_plate_tmod, dest_well_plate_tmod],\n                                [DNA_plate_slots[0], dest_plate_slot]):\n        if tmod_lname:\n            tmod = ctx.load_module(tmod_lname, slot)\n            tmod_list.append(tmod)\n        else:\n            tmod_list.append(None)\n    tmod_dna_plate, tmod_dest_plate = tmod_list\n    '''\n\n\n    Add your labware here with:\n    labware_name = ctx.load_labware('{loadname}', '{slot number}')\n\n    If loading labware on a module, you can load with:\n\n    labware_name = module_name.load_labware('{loadname}')\n    where module_name is defined above.\n\n    '''\n\n    # labware setup\n    plate_list = []\n    for labware_lname, tmod, slot, name in \\\n        zip([DNA_well_plate_lname, destination_well_plate_lname],\n            [tmod_dna_plate, tmod_dest_plate],\n            [DNA_plate_slots[0], dest_plate_slot],\n            [\"DNA plate 1\", \"destination plate\"]):\n        if tmod:\n            plate_list.append(tmod.load_labware(labware_lname, name))\n        else:\n            plate_list.append(ctx.load_labware(labware_lname, slot, name))\n\n    DNA_well_plate_1, destination_well_plate = plate_list\n    DNA_well_plates = [DNA_well_plate_1]\n    for i, slot in enumerate(DNA_plate_slots[1:n_plates]):\n        DNA_well_plates.append(ctx.load_labware(DNA_well_plate_lname, slot,\n                                                \"DNA plate {}\".format(i+2)))\n\n    mastermix_reservoir = ctx.load_labware(mastermix_reservoir_lname,\n                                           mastermix_resv_slot,\n                                           'mastermix reservoir')\n    # load tipracks\n    '''\n\n\n    Add your tipracks here as a list:\n\n    For\n    a single tip rack:\n    tiprack_name = [ctx.load_labware('{loadname}', '{slot number}')]\n\n    For multiple tip racks of the same type:\n\n    tiprack_name = [ctx.load_labware('{loadname}', 'slot')\n                     for slot in ['1', '2', '3']]\n\n    If two different tipracks are on the deck, use convention:\n    tiprack[ number of microliters]\n    e. g. tiprack10, tiprack20, tiprack200, tiprack300, tiprack1000\n    '''\n\n    tiprack_lnames = {\n        \"p20s_filtered\": \"opentrons_96_filtertiprack_20ul\",\n        \"p20s_nonfiltered\": \"opentrons_96_tiprack_20ul\",\n        \"p300s_filtered\": \"opentrons_96_filtertiprack_200ul\",\n        \"p300s_nonfiltered\": \"opentrons_96_tiprack_300ul\",\n        \"p1000s_filtered\": \"opentrons_96_filtertiprack_1000ul\",\n        \"p1000s_nonfiltered\": \"opentrons_96_tiprack_1000ul\"\n    }\n\n    # Helper function for loading tipracks\n    def load_tipracks(tiprack_list, filtered_tips, non_filtered_tips,\n                      is_filtered, slot):\n        tip_type = filtered_tips if is_filtered else non_filtered_tips\n        tiprack_list.append([ctx.load_labware(tip_type, s) for s in slot])\n\n    tiprack_list = []\n\n    for pip_lname, is_filtered, slot \\\n        in zip([left_pipette_lname, right_pipette_lname],\n               [use_filter_tips_left, use_filter_tips_right],\n               [tiprack_l_slots, tiprack_r_slots]):\n        if not pip_lname:\n            tiprack_list.append(None)\n        elif \"20_\" in pip_lname or \"10_\" in pip_lname:\n            load_tipracks(tiprack_list, tiprack_lnames[\"p20s_filtered\"],\n                          tiprack_lnames[\"p20s_nonfiltered\"], is_filtered,\n                          slot)\n        elif \"300_\" in pip_lname or \"50_\" in pip_lname:\n            load_tipracks(tiprack_list, tiprack_lnames[\"p300s_filtered\"],\n                          tiprack_lnames[\"p300s_nonfiltered\"], is_filtered,\n                          slot)\n        elif \"1000_\" in pip_lname:\n            load_tipracks(tiprack_list, tiprack_lnames[\"p1000s_filtered\"],\n                          tiprack_lnames[\"p1000s_nonfiltered\"], is_filtered,\n                          slot)\n        else:\n            raise Exception(\"The pipette loadname does not match any tipracks \"\n                            \"the loadname was {}\".format(pip_lname))\n    # load instrument\n    '''\n    Nomenclature for pipette:\n\n    use 'p' for single-channel, 'm' for multi-channel,\n    followed by number of microliters.\n\n    p20, p300, p1000 (single channel pipettes)\n    m20, m300 (multi-channel pipettes)\n\n    If loading pipette, load with:\n    ctx.load_instrument('{pipette api load name}',\n                        pipette_mount(\"left\", or \"right\"),\n                        tip_racks= tiprack )\n    '''\n\n    pipettes = []\n    for pip, mount, tiprack in zip([left_pipette_lname, right_pipette_lname],\n                                   [\"left\", \"right\"],\n                                   tiprack_list):\n        if pip:\n            pipettes.append(ctx.load_instrument(pip, mount, tip_racks=tiprack))\n        else:\n            pipettes.append(None)\n\n    for pip in pipettes:\n        if pip is not None:\n            pip.flow_rate.aspirate *= aspiration_rate_multiplier\n            pip.flow_rate.dispense *= dispensation_rate_multiplier\n    '''\n\n    Define all pipette functions, and class extensions here.\n    These may include but are not limited to:\n\n    - Custom pickup functions\n    - Custom drop tip functions\n    - Custom Tip tracking functions\n    - Custom Trash tracking functions\n    - Slow tip withdrawal\n\n    For any functions in your protocol, describe the function as well as\n    describe the parameters which are to be passed in as a docstring below\n    the function.\n    '''\n    def is_multi_channel(pip): return True if pip.channels == 8 else False\n\n    def mix(pipette: InstrumentContext, n_mixes, vol, location):\n        if n_mixes == 0:\n            return\n        else:\n            pipette.mix(n_mixes, vol, location)\n\n    def pick_up_tip(pipette):\n        \"\"\"\n        Safe function for picking up tips in that it checks for tip\n        availability and asks user to replace tips if the tipracks\n        have run empty.\n\n        :param pipette: Pipette to pick up tip with\n        \"\"\"\n        try:\n            pipette.pick_up_tip()\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Replace empty tip racks\")\n            pipette.reset_tipracks()\n            pipette.pick_up_tip()\n\n    def rank_pipettes(pipettes):\n        \"\"\"\n        Given a list of 1 to 2 pipettes this fn will return them in the order\n        of smallest to largest. This function assumes that error checking for\n        cases where no pipettes were loaded was already done.\n        \"\"\"\n        if pipettes[1] is None:\n            return [pipettes[0], pipettes[0]]\n        elif pipettes[0] is None:\n            return [pipettes[1], pipettes[1]]\n        elif len(pipettes) == 2:\n            if pipettes[0].max_volume <= pipettes[1].max_volume:\n                return [pipettes[0], pipettes[1]]\n            else:\n                return [pipettes[1], pipettes[0]]\n        else:\n            raise Exception(\"Unexpected number of pipettes loaded: {}\".\n                            format(len(pipettes)))\n\n    def pipette_selector(small_pipette, large_pipette, volume):\n        \"\"\"\n        This function will try to return a multi-channel pipette that\n        can handle the given volume, and failing that a single channel pip.\n        \"\"\"\n        assert small_pipette.max_volume \\\n            <= large_pipette.max_volume, (\"Pipette argument error, small pip's\"\n                                          \" max volume should be less than or \"\n                                          \"equal to the large pip's\")\n        if small_pipette.min_volume <= volume <= small_pipette.max_volume \\\n                and is_multi_channel(small_pipette):\n            return small_pipette\n        elif large_pipette.min_volume <= volume \\\n                and is_multi_channel(large_pipette):\n            return large_pipette\n        elif small_pipette.min_volume <= volume <= small_pipette.max_volume:\n            return small_pipette\n        elif large_pipette.min_volume <= volume:\n            return large_pipette\n        else:\n            raise Exception(\"No suitable pipette for a volume of {} loaded\".\n                            format(volume))\n\n    # helper functions\n    ''' Define any custom helper functions outside of the pipette scope here,\n    using the convention seen above.\n    e.g.\n    def\n        remove_supernatant(vol, index):\n        \"\"\"\n        function description\n        : param vol:\n        : param index:\n        \"\"\"\n\n    '''\n\n    def single_channel_resv_transfer(pipette, vol, source_well, dest_plate,\n                                     n_samples, drop_tips=False):\n        \"\"\"\n        This function transfers a volume of liquid from a single source well\n        (e.g. a reservoir) to a destination plate using a single channel\n        pipette\n        :param pipette: The pipette to use for transferring liquid\n        :param vol: The volume for each liquid transfer\n        :param source_well: The source well to aspirate from, i.e. the\n        reservoir well containing mastermix\n        :param dest_plate: well plate to transfer to\n        :param n_samples: How many transfers to perform\n        :param drop_tips: Whether to drop tips after each transfer and pick\n        up new ones, or reuse the same tips\n        \"\"\"\n        if not drop_tips:\n            pick_up_tip(pipette)\n        for well in dest_plate.wells()[:n_samples]:\n            if drop_tips:\n                pick_up_tip(pipette)\n            pipette.aspirate(vol, source_well)\n            pipette.dispense(vol, well)\n            if drop_tips:\n                pipette.drop_tip()\n        if not drop_tips:\n            pipette.drop_tip()\n\n    def single_channel_plate_transfer(pipette, vol, source_plate, dest_plate,\n                                      n_mixes, mix_vol, n_transfers, offset=0):\n        for s_well, d_well in zip(source_plate.wells()[:n_transfers],\n                                  dest_plate.wells()\n                                  [offset:n_transfers+offset]):\n            \"\"\" This function transfers a volume of liquid from a source plate\n            to a destination plate using a single channel pipette\n            :param offset: Dispense in the well on the target plate starting\n            at the offset from the 1st well.\n            :param pipette: The (single channel) pipette to use for\n            transferring liquid\n            :param vol: The volume for each liquid transfer\n            :param source_plate: well plate to transfer from\n            :param dest_plate: well plate to transfer to\n            :param n_mixes: how many times to mix the solution after the\n            transfer\n            :param mix_vol: The mixing volume for the mixing actions\n            :param n_transfers: How many samples to transfer to the target\n            plate from the source plate\n            :param offset: Offset defines how many wells to skip on the target\n            plate before transferring e.g. if the offset is 96, the transfers\n            begin in well 97 on the target plate\n            \"\"\"\n            pick_up_tip(pipette)\n            pipette.aspirate(vol, s_well)\n            pipette.dispense(vol, d_well)\n            mix(pipette, n_mixes, mix_vol, d_well)\n            pipette.drop_tip()\n\n    def resv_to_plate384_transfer(pipette, vol, source_well, dest_plate,\n                                  n_samples, drop_tips=False):\n        \"\"\"\n        Transfer from a reservoir to a plate. If the pipette is multi channel\n        the transfers will be column to column.\n\n        :param pipette: Pipette for the pipetting actions (aspirate/dispense)\n        :param vol: The volume per tip to transfer\n        :param source_well: The reservoir well to transfer from\n        :param dest_plate: The plate to transfer to\n        :param drop_tips: Whether to drop tips after each transfer or use the\n        same tips throughout. Defaults to false\n        \"\"\"\n        if not len(dest_plate.columns()[0]) == 16:\n            raise Exception(\"The 384(?) well destination plate should have 16 \"\n                            \"wells in in each row but it has {} wells instead\".\n                            format(len(dest_plate.columns())))\n        # If the pip is multi-channel transfer from the resv well to the A\n        # row well of the column and then the B row well, filling all 16\n        # wells of the 384 well plate\n        if is_multi_channel(pipette):\n            n_columns = math.ceil(n_samples/16)\n            target_columns = dest_plate.columns()[:n_columns]\n            if not drop_tips:\n                pick_up_tip(pipette)\n            for col in target_columns:\n                for i in range(2):\n                    # col[0] = A row, col[1] = B row of the column\n                    d_well = col[i]\n                    if drop_tips:\n                        pick_up_tip(pipette)\n                    pipette.aspirate(vol, source_well)\n                    pipette.dispense(vol, d_well)\n                    if drop_tips:\n                        pipette.drop_tip()\n            if not drop_tips:\n                pipette.drop_tip()\n        # Single channel pip: well to well\n        else:\n            single_channel_resv_transfer(\n                pipette, vol, source_well, dest_plate, n_samples, drop_tips)\n\n    def resv_to_plate96_transfer(pipette, vol, source_well, dest_plate,\n                                 n_samples, drop_tips=False):\n        \"\"\"\n        Transfer from a reservoir to a 96 well plate. If the pipette is multi\n        channel the transfers will be reservoir to column (well A of each col).\n        This function can also use a single channel pipette to transfer to\n        each well\n\n        :param pipette: Pipette for the pipetting actions\n        :param vol: The volume per tip to transfer\n        :param source_well: The reservoir well to transfer from\n        :param dest_plate: The plate to transfer to\n        :param n_samples: How many (mastermix) samples to transfer\n        :param drop_tips: Whether to drop tips after each transfer or use the\n        same tips throughout. Defaults to False\n        \"\"\"\n        # If the pip is multi-channel transfer to the a row well of each col\n        if is_multi_channel(pipette):\n            n_columns = math.ceil(n_samples/8)\n            target_columns = dest_plate.columns()[:n_columns]\n            if not drop_tips:\n                pick_up_tip(pipette)\n            for col in target_columns:\n                if drop_tips:\n                    pick_up_tip(pipette)\n                pipette.aspirate(vol, source_well)\n                pipette.dispense(vol, col[0])\n                if drop_tips:\n                    pipette.drop_tip()\n            if not drop_tips:\n                pipette.drop_tip()\n        # Single channel pip: well to well\n        else:\n            single_channel_resv_transfer(\n                pipette, vol, source_well, dest_plate, n_samples, drop_tips)\n\n    def plate96_to_plate96_transfer(pipette, vol, source_plate, dest_plate,\n                                    n_samples, n_mixes, mix_vol):\n        \"\"\"\n        Transfer from a 96 well plate to a 96 well plate.\n        This function can use either a multi-channel pipette or a single\n        channel pipette.\n\n        :param pipette: Pipette for the pipetting actions\n        :param vol: The volume per tip to transfer\n        :param source_plate: The well plate to transfer from\n        :param dest_plate: The well plate to transfer to\n        :param n_mixes: How many times to mix after dispensing\n        :param mix_vol: Mixing volume\n        \"\"\"\n        # Multi-channel pip: column by column transfer\n        if is_multi_channel(pipette):\n            n_columns = math.ceil(n_samples/8)\n            source_columns = source_plate.columns()[0:n_columns-1]\n            target_columns = dest_plate.columns()[0:n_columns-1]\n            for s_col, d_col in zip(source_columns, target_columns):\n                pick_up_tip(pipette)\n                pipette.aspirate(vol, s_col[0])\n                pipette.dispense(vol, d_col[0])\n                mix(pipette, n_mixes, mix_vol, d_col[0])\n                pipette.drop_tip()\n        # SCP: well by well transfer\n        else:\n            single_channel_plate_transfer(pipette, vol, source_plate,\n                                          dest_plate, n_mixes,\n                                          mix_vol, n_samples)\n\n    def plate96_to_plate384_transfer(pipette, vol, source_plate, dest_plate,\n                                     n_samples, offset_samples, n_mixes,\n                                     mix_vol):\n        \"\"\"\n        Transfer from a well plate to a well plate.\n        If the pipette is multi channel the transfers will be column to column.\n\n        :param pipette: Pipette for the pipetting actions\n        :param vol: The volume per tip to transfer\n        :param source_plate: The 96 well plate to transfer from\n        :param dest_plate: The 384 well plate to transfer to\n        :param n_samples: How many samples to transfer from the 96 well plate\n        :param offset_samples: Used to compute the offset column on the 384\n        well plate, for example if 96 samples have been added then 6 columns\n        on the 384 well plate have been filled so the next column should be\n        no. 7\n        :param n_mixes: How many times to mix after dispensing\n        :param mix_vol: Mixing volume\n        \"\"\"\n\n        # Error check\n        s_len = len(source_plate.wells())\n        d_len = len(dest_plate.wells())\n        if s_len != 96 or d_len != 384:\n            raise Exception((\"Source plate should have 96 wells if the \"\n                             \"destination plate has 384, but they \"\n                             \"have {} and {} wells\").format(s_len, d_len))\n        # Multi-channel pip: column by column transfer\n        if is_multi_channel(pipette):\n            # Number of columns in the 96 well plate to pick samples from\n            n_columns_96 = math.ceil(n_samples/8)\n            offset_columns_384 = math.ceil(offset_samples/16)\n\n            source_wells = [column[0] for column\n                            in source_plate.columns()[:n_columns_96]]\n            target_wells = []\n            for i in range(n_columns_96):\n                i_col_384 = i//2 + offset_columns_384\n                if i % 2 == 0:\n                    target_wells.append(dest_plate.columns()[i_col_384][0])\n                else:\n                    target_wells.append(dest_plate.columns()[i_col_384][1])\n\n            for s_well, d_well in zip(source_wells, target_wells):\n                pick_up_tip(pipette)\n                pipette.aspirate(vol, s_well)\n                pipette.dispense(vol, d_well)\n                mix(pipette, n_mixes, mix_vol, d_well)\n                pipette.drop_tip()\n        # SCP: well by well transfer\n        else:\n            single_channel_plate_transfer(pipette, vol, source_plate,\n                                          dest_plate, n_mixes,\n                                          mix_vol, n_samples, offset=offset)\n\n    def plate384_to_plate384_transfer(pipette, vol, source_plate, dest_plate,\n                                      n_samples, n_mixes, mix_vol):\n        \"\"\"\n        Transfer from a 384 well plate to a 384 well plate.\n        If the pipette is multi channel the transfers will be column to column.\n\n        :param pipette: Pipette for the pipetting actions\n        :param vol: The volume per tip to transfer\n        :param source_plate: The 96 well plate to transfer from\n        :param dest_plate: The 384 well plate to transfer to\n        :n_samples: How many samples to transfer, 384 for the whole plate\n        :param n_mixes: How many times to mix after dispensing\n        :param mix_vol: Mixing volume\n        \"\"\"\n        # Error check\n        s_len = len(source_plate.wells())\n        d_len = len(dest_plate.wells())\n        if not s_len == 384 and d_len == 384:\n            raise Exception((\"The source and destination plate should have \"\n                             \"384 wells, but they have {} and {} wells\").\n                            format(s_len, d_len))\n        # Multi-channel pip: column by column transfer\n        if is_multi_channel(pipette):\n            n_8chl_transfers = math.ceil(n_samples/8)\n            source_wells = []\n            target_wells = []\n            for i in range(n_8chl_transfers):\n                if i % 2 == 0:\n                    source_wells.append(source_plate.columns()[i//2][0])\n                    target_wells.append(dest_plate.columns()[i//2][0])\n                else:\n                    source_wells.append(source_plate.columns()[i//2][1])\n                    target_wells.append(dest_plate.columns()[i//2][1])\n            for s_well, d_well in zip(source_wells, target_wells):\n                pick_up_tip(pipette)\n                pipette.aspirate(vol, s_well)\n                pipette.dispense(vol, d_well)\n                mix(pipette, n_mixes, mix_vol, d_well)\n                pipette.drop_tip()\n        # SCP: well by well transfer\n        else:\n            single_channel_plate_transfer(pipette, vol, source_plate,\n                                          dest_plate, n_mixes,\n                                          mix_vol, n_samples)\n    # reagents\n    '''\n    Define where all reagents are on the deck using the labware defined above.\n\n    e.g.\n\n    water = reservoir12.wells()[-1]\n    waste = reservoir.wells()[0]\n    samples = plate.rows()[0][0]\n    dnase = tuberack.wells_by_name()['A4']\n\n    '''\n    mastermix = mastermix_reservoir.wells()[0]\n\n    '''\n\n    Include header sections as follows for each \"section\" of your protocol.\n\n    Section can be defined as a step in a bench protocol.\n\n    e.g.\n\n    ctx.comment('\\n\\nMOVING MASTERMIX TO SAMPLES IN COLUMNS 1-6\\n')\n\n    for .... in ...:\n        ...\n        ...\n\n    ctx.comment('\\n\\nRUNNING THERMOCYCLER PROFILE\\n')\n    '''\n\n    n_wells_source = len(DNA_well_plates[0].wells())\n    n_wells_dest = len(destination_well_plate.wells())\n    if n_wells_dest < n_samples:\n        raise Exception(\"The destination plate does not have enough wells ({})\"\n                        \"for all the samples ({}). Check your number of \"\n                        \"samples parameter\".\n                        format(n_wells_dest, n_samples))\n\n    # determine which pipette has the smaller volume range\n    pip_s, pip_l = rank_pipettes(pipettes)\n    # Make sure we have a pipette that can handle the volume of mastermix\n    # Ideally the smaller one\n    pipette = pipette_selector(pip_s, pip_l, mastermix_volume)\n    ctx.comment(\"\\n\\nTransferring master mix to target plate\\n\")\n    if n_wells_dest == 96:\n        resv_to_plate96_transfer(pipette, mastermix_volume, mastermix,\n                                 destination_well_plate, n_samples)\n    elif n_wells_dest == 384:\n        resv_to_plate384_transfer(pipette, mastermix_volume, mastermix,\n                                  destination_well_plate, n_samples)\n    else:\n        raise Exception(\"Transferring to a {} well plate is unsupported\".\n                        format(n_wells_dest))\n\n    # Transfer DNA to the destination plate\n    pipette = pipette_selector(pip_s, pip_l, DNA_volume)\n    ctx.comment(\"\\n\\nTransferring DNA to target plate\\n\")\n    mixing_volume = DNA_volume + mastermix_volume - 1\n    if n_wells_source == 96:\n        if n_wells_dest == 96:\n            # 96 well to 96 well plate transfer\n            plate96_to_plate96_transfer(pipette, DNA_volume,\n                                        DNA_well_plate_1,\n                                        destination_well_plate, n_samples,\n                                        n_mixes, mixing_volume,)\n        # DNA transfer from 1 up to 4 96 well plates to 384 well plate\n        elif n_wells_dest == 384:\n            offset = 0\n            i = 0\n            while offset < n_samples:\n                remaining_samples = n_samples - offset\n                samples = remaining_samples if remaining_samples < 96 else 96\n                plate96_to_plate384_transfer(\n                    pipette, DNA_volume, DNA_well_plates[i],\n                    destination_well_plate, samples, offset,\n                    n_mixes, mixing_volume)\n                offset += samples\n                i += 1\n        else:\n            raise Exception(\n                \"The destination plate has an unexpected number of wells: {}\".\n                format(n_wells_dest))\n    elif n_wells_source == 384 and n_wells_dest == 384:\n        plate384_to_plate384_transfer(pipette, DNA_volume, DNA_well_plate_1,\n                                      destination_well_plate, n_samples,\n                                      n_mixes, mixing_volume)\n    else:\n        raise Exception(\n            (\"The protocol has not implemnted transfers from a {} to a {} \"\n             \"well plate\").format(n_wells_source, n_wells_dest))\n    ctx.comment(\"\\n\\n~~~~ Protocol complete ~~~~\\n\")\n",
    "custom_labware_defs": [],
    "fields": [
        {
            "default": 384,
            "label": "Number of samples",
            "name": "n_samples",
            "type": "int"
        },
        {
            "default": 5,
            "label": "Number of mixes",
            "name": "n_mixes",
            "type": "int"
        },
        {
            "default": 1,
            "label": "Aspiration rate multiplier",
            "name": "aspiration_rate_multiplier",
            "type": "float"
        },
        {
            "default": 1,
            "label": "Dispensation rate multiplier",
            "name": "dispensation_rate_multiplier",
            "type": "float"
        },
        {
            "label": "Left pipette type",
            "name": "left_pipette_lname",
            "options": [
                {
                    "label": "P20 Multi GEN2",
                    "value": "p20_multi_gen2"
                },
                {
                    "label": "P300 Multi GEN2",
                    "value": "p300_multi_gen2"
                },
                {
                    "label": "P1000 Single GEN2",
                    "value": "p1000_single_gen2"
                },
                {
                    "label": "P300 Single GEN2",
                    "value": "p300_single_gen2"
                },
                {
                    "label": "P20 Single GEN2",
                    "value": "p20_single_gen2"
                },
                {
                    "label": "P10 Multi",
                    "value": "p10_multi"
                },
                {
                    "label": "P50 Multi",
                    "value": "p50_multi"
                },
                {
                    "label": "P300 Multi",
                    "value": "p300_multi"
                },
                {
                    "label": "P1000 Single",
                    "value": "p1000_single"
                },
                {
                    "label": "P300 Single",
                    "value": "p300_single"
                },
                {
                    "label": "P50 Single",
                    "value": "p50_single"
                },
                {
                    "label": "P20 Single",
                    "value": "p20_single"
                },
                {
                    "label": "None",
                    "value": false
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Right pipette type",
            "name": "right_pipette_lname",
            "options": [
                {
                    "label": "P300 Multi GEN2",
                    "value": "p300_multi_gen2"
                },
                {
                    "label": "P20 Multi GEN2",
                    "value": "p20_multi_gen2"
                },
                {
                    "label": "P1000 Single GEN2",
                    "value": "p1000_single_gen2"
                },
                {
                    "label": "P300 Single GEN2",
                    "value": "p300_single_gen2"
                },
                {
                    "label": "P20 Single GEN2",
                    "value": "p20_single_gen2"
                },
                {
                    "label": "P10 Multi",
                    "value": "p10_multi"
                },
                {
                    "label": "P50 Multi",
                    "value": "p50_multi"
                },
                {
                    "label": "P300 Multi",
                    "value": "p300_multi"
                },
                {
                    "label": "P1000 Single",
                    "value": "p1000_single"
                },
                {
                    "label": "P300 Single",
                    "value": "p300_single"
                },
                {
                    "label": "P50 Single",
                    "value": "p50_single"
                },
                {
                    "label": "P20 Single",
                    "value": "p20_single"
                },
                {
                    "label": "None",
                    "value": false
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Filtered or unfiltered tips for the left pipette?",
            "name": "use_filter_tips_left",
            "options": [
                {
                    "label": "Filter tips",
                    "value": true
                },
                {
                    "label": "Regular tips",
                    "value": false
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Filtered or unfiltered tips for the right pipette?",
            "name": "use_filter_tips_right",
            "options": [
                {
                    "label": "Filter tips",
                    "value": true
                },
                {
                    "label": "Regular tips",
                    "value": false
                }
            ],
            "type": "dropDown"
        },
        {
            "default": 18,
            "label": "Mastermix volume (in ul)",
            "name": "mastermix_volume",
            "type": "float"
        },
        {
            "default": 2,
            "label": "DNA volume (in ul)",
            "name": "DNA_volume",
            "type": "float"
        },
        {
            "label": "Mastermix reservoir",
            "name": "mastermix_reservoir_lname",
            "options": [
                {
                    "label": "NEST 12 Well Reservoir 15 mL",
                    "value": "nest_12_reservoir_15ml"
                },
                {
                    "label": "NEST 1 Well Reservoir 195 mL",
                    "value": "nest_1_reservoir_195ml"
                },
                {
                    "label": "NEST 96 Deepwell plate 2 mL",
                    "value": "nest_96_wellplate_2ml_deep"
                },
                {
                    "label": "USA Scientific 12 Well Reservoir 22 mL",
                    "value": "usascientific_12_reservoir_22ml"
                },
                {
                    "label": "Agilent 1 Well Reservoir 290 mL",
                    "value": "agilent_1_reservoir_290ml"
                },
                {
                    "label": "Axygen 1 Well Reservoir 90 mL",
                    "value": "axygen_1_reservoir_90ml"
                },
                {
                    "label": "USA Scientific 96 Deep well Plate 2.4 mL",
                    "value": "usascientific_96_wellplate_2.4ml_deep"
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "PCR well plate (or PCR strips) containing template DNA",
            "name": "DNA_well_plate_lname",
            "options": [
                {
                    "label": "NEST 96 Well Plate 100 \u00b5L PCR Full Skirt",
                    "value": "nest_96_wellplate_100ul_pcr_full_skirt"
                },
                {
                    "label": "Bio-Rad 96 well 200 uL PCR plate",
                    "value": "biorad_96_wellplate_200ul_pcr"
                },
                {
                    "label": "Corning 384 Well Plate 112 \u00b5L Flat",
                    "value": "corning_384_wellplate_112ul_flat"
                },
                {
                    "label": "Corning 96 Well Plate 360 \u00b5L Flat",
                    "value": "corning_96_wellplate_360ul_flat"
                },
                {
                    "label": "Opentrons 96 Well Aluminum Block with NEST Well Plate 100 \u00b5L",
                    "value": "opentrons_96_aluminumblock_nest_wellplate_100ul"
                },
                {
                    "label": "Opentrons 96 Well Aluminum Block with Generic PCR Strip 200 uL",
                    "value": "opentrons_96_aluminumblock_generic_pcr_strip_200ul"
                },
                {
                    "label": "Opentrons 96 Well Aluminum Block with Bio-Rad Well Plate 200 \u00b5L",
                    "value": "opentrons_96_aluminumblock_biorad_wellplate_200ul"
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Destination PCR well plate or PCR strips",
            "name": "destination_well_plate_lname",
            "options": [
                {
                    "label": "Corning 384 Well Plate 112 \u00b5L Flat",
                    "value": "corning_384_wellplate_112ul_flat"
                },
                {
                    "label": "NEST 96 Well Plate 100 \u00b5L PCR Full Skirt",
                    "value": "nest_96_wellplate_100ul_pcr_full_skirt"
                },
                {
                    "label": "Bio-Rad 96 well 200 uL PCR plate",
                    "value": "biorad_96_wellplate_200ul_pcr"
                },
                {
                    "label": "Corning 96 Well Plate 360 \u00b5L Flat",
                    "value": "corning_96_wellplate_360ul_flat"
                },
                {
                    "label": "Opentrons 96 Well Aluminum Block with NEST Well Plate 100 \u00b5L",
                    "value": "opentrons_96_aluminumblock_nest_wellplate_100ul"
                },
                {
                    "label": "Opentrons 96 Well Aluminum Block with Generic PCR Strip 200 uL",
                    "value": "opentrons_96_aluminumblock_generic_pcr_strip_200ul"
                },
                {
                    "label": "Opentrons 96 Well Aluminum Block with Bio-Rad Well Plate 200 \u00b5L",
                    "value": "opentrons_96_aluminumblock_biorad_wellplate_200ul"
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Temperature module for the template sample well plate",
            "name": "DNA_well_plate_tmod",
            "options": [
                {
                    "label": "None",
                    "value": false
                },
                {
                    "label": "Temperature module Gen2",
                    "value": "temperature module gen2"
                },
                {
                    "label": "Temperature module Gen1",
                    "value": "temperature module"
                }
            ],
            "type": "dropDown"
        },
        {
            "label": "Temperature module for the destination well plate",
            "name": "dest_well_plate_tmod",
            "options": [
                {
                    "label": "None",
                    "value": false
                },
                {
                    "label": "Temperature module Gen2",
                    "value": "temperature module gen2"
                },
                {
                    "label": "Temperature module Gen1",
                    "value": "temperature module"
                }
            ],
            "type": "dropDown"
        }
    ],
    "instruments": [
        {
            "mount": "right",
            "name": "p20_multi_gen2"
        }
    ],
    "labware": [
        {
            "name": "mastermix reservoir on 3",
            "share": false,
            "slot": "3",
            "type": "nest_12_reservoir_15ml"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 20 \u00b5L on 5",
            "share": false,
            "slot": "5",
            "type": "opentrons_96_filtertiprack_20ul"
        },
        {
            "name": "destination plate on Temperature Module GEN2 on 6",
            "share": false,
            "slot": "6",
            "type": "opentrons_96_aluminumblock_nest_wellplate_100ul"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 20 \u00b5L on 8",
            "share": false,
            "slot": "8",
            "type": "opentrons_96_filtertiprack_20ul"
        },
        {
            "name": "DNA plate 1 on Temperature Module GEN2 on 9",
            "share": false,
            "slot": "9",
            "type": "opentrons_96_aluminumblock_nest_wellplate_100ul"
        },
        {
            "name": "Opentrons Fixed Trash on 12",
            "share": false,
            "slot": "12",
            "type": "opentrons_1_trash_1100ml_fixed"
        }
    ],
    "metadata": {
        "apiLevel": "2.11",
        "author": "Opentrons <protocols@opentrons.com>",
        "protocolName": "Generic PCR Prep Part 2 - Mastermix and DNA Distribution",
        "source": "Protocol Library"
    },
    "modules": []
}