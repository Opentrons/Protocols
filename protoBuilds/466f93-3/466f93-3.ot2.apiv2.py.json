{
    "content": "\"\"\"DNA cleanup and PCR amplification protocol.\"\"\"\nfrom opentrons import protocol_api\nimport math\n\n# Protocol part 3 - DNA cleanup and PCR amplification\nmetadata = {\n    'protocolName': '466f93-3 - Automated LifeCell_NIPT_35Plex_HV',\n    'author': 'Eskil Andersen <eskil.andersen@opentrons.com>',\n    'source': 'Custom Protocol Request',\n    'apiLevel': '2.11'   # CHECK IF YOUR API LEVEL HERE IS UP TO DATE\n                         # IN SECTION 5.2 OF THE APIV2 \"VERSIONING\"\n}\n\n\ndef run(ctx: protocol_api.ProtocolContext):\n    \"\"\"DNA cleanup and PCR amplification protocol entry point.\"\"\"\n    [\n     num_samples,\n     mag_engage_time\n    ] = get_values(  # noqa: F821 (<--- DO NOT REMOVE!)\n        \"num_samples\",\n        \"mag_engage_time\"\n        )\n\n    if not 7 <= num_samples <= 36:\n        raise Exception(\"The number of samples should be between 7 and 36\")\n\n    # define all custom variables above here with descriptions:\n    bead_volume = 25  # volume of bead solution for each sample\n    bead_source_well_volume = 127\n    ethanol_wash_vol = 75  # Volume of EtOH per bead wash\n    water_resuspension_vol = 14  # Volume to resuspend SPRI beads in\n    DNA_supernat_transfer_volume = 12  # Amount of DNA supernat. per PCR sample\n\n    PCR_mastermix_vol_per_sample = 12.5  # Amount of mm per PCR sample\n    PCR_mm_vol_per_source_well = 117  # Volume of mm per well in RP-I\n    primer_vol_per_sample = 0.5  # Primer volume per PCR sample on dest plate\n    # Combined PCR mastermix + primer mix per PCR sample`\n    PCR_smm_vol_per_sample = \\\n        (PCR_mastermix_vol_per_sample + primer_vol_per_sample)\n\n    PCR_sample_total_vol = 25  # Volume of DNA + super-mastermix\n\n    n_standard_mixes = 10  # Standard number of times to mix a sample (10)\n    # Standard number of times to mix mag soln. (25)\n    n_bead_solution_mixes = 25\n\n    # load modules\n    mag_mod = ctx.load_module('magnetic module gen2', '3')\n\n    '''\n\n    Add your modules here with:\n\n    module_name = ctx.load_module('{module_loadname}', '{slot number}')\n\n    Note: if you are loading a thermocycler, you do not need to specify\n    a slot number - thermocyclers will always occupy slots 7, 8, 10, and 11.\n\n    For all other modules, you can load them on slots 1, 3, 4, 6, 7, 9, 10.\n\n    '''\n\n    # load labware\n    yourgene_reagent_plate_I \\\n        = ctx.load_labware('biorad_96_wellplate_200ul_pcr', '7',\n                           'Reagent Plate - I')\n    barcoded_sample_mag_plate \\\n        = mag_mod.load_labware('biorad_96_wellplate_200ul_pcr',\n                               'Magnetic module sample plate')\n    SPRI_bead_plate \\\n        = ctx.load_labware('biorad_96_wellplate_200ul_pcr', '9',\n                           'Magnetic bead plate')\n    reservoir \\\n        = ctx.load_labware('nest_12_reservoir_15ml', '6',\n                           'Reagent reservoir')\n    PCR_destination_plate \\\n        = ctx.load_labware('biorad_96_wellplate_200ul_pcr', '2',\n                           'PCR plate')\n\n    '''\n\n    Add your labware here with:\n\n    labware_name = ctx.load_labware('{loadname}', '{slot number}')\n\n    If loading labware on a module, you can load with:\n\n    labware_name = module_name.load_labware('{loadname}')\n    where module_name is defined above.\n\n    '''\n\n    # load tipracks\n\n    '''\n\n    Add your tipracks here as a list:\n\n    For a single tip rack:\n\n    tiprack_name = [ctx.load_labware('{loadname}', '{slot number}')]\n\n    For multiple tip racks of the same type:\n\n    tiprack_name = [ctx.load_labware('{loadname}', 'slot')\n                     for slot in ['1', '2', '3']]\n\n    If two different tipracks are on the deck, use convention:\n    tiprack[number of microliters]\n    e.g. tiprack10, tiprack20, tiprack200, tiprack300, tiprack1000\n\n    '''\n    tiprack20s = [ctx.load_labware('opentrons_96_filtertiprack_20ul', slot)\n                  for slot in ['10', '11']]\n    tiprack200s = [ctx.load_labware('opentrons_96_filtertiprack_200ul', slot)\n                   for slot in ['5', '8']]\n\n    # load instrument\n\n    '''\n    Nomenclature for pipette:\n\n    use 'p'  for single-channel, 'm' for multi-channel,\n    followed by number of microliters.\n\n    p20, p300, p1000 (single channel pipettes)\n    m20, m300 (multi-channel pipettes)\n\n    If loading pipette, load with:\n\n    ctx.load_instrument(\n                        '{pipette api load name}',\n                        pipette_mount (\"left\", or \"right\"),\n                        tip_racks=tiprack\n                        )\n    '''\n    p20 = ctx.load_instrument(\"p20_single_gen2\", \"left\", tip_racks=tiprack20s)\n    p300 = ctx.load_instrument(\"p300_single_gen2\", \"right\",\n                               tip_racks=tiprack200s)\n\n    # pipette functions   # INCLUDE ANY BINDING TO CLASS\n\n    '''\n\n    Define all pipette functions, and class extensions here.\n    These may include but are not limited to:\n\n    - Custom pickup functions\n    - Custom drop tip functions\n    - Custom Tip tracking functions\n    - Custom Trash tracking functions\n    - Slow tip withdrawal\n\n    For any functions in your protocol, describe the function as well as\n    describe the parameters which are to be passed in as a docstring below\n    the function (see below).\n\n    def pick_up(pipette):\n        \"\"\"`pick_up()` will pause the protocol when all tip boxes are out of\n        tips, prompting the user to replace all tip racks. Once tipracks are\n        reset, the protocol will start picking up tips from the first tip\n        box as defined in the slot order when assigning the labware definition\n        for that tip box. `pick_up()` will track tips for both pipettes if\n        applicable.\n\n        :param pipette: The pipette desired to pick up tip\n        as definited earlier in the protocol (e.g. p300, m20).\n        \"\"\"\n        try:\n            pipette.pick_up_tip()\n        except protocol_api.labware.protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Replace empty tip racks\")\n            pipette.reset_tipracks()\n            pipette.pick_up_tip()\n\n    '''\n    def drop_all_tips():\n        for pip in [p20, p300]:\n            if pip.has_tip:\n                pip.drop_tip()\n\n    # helper functions\n    '''\n    Define any custom helper functions outside of the pipette scope here, using\n    the convention seen above.\n\n    e.g.\n\n    def remove_supernatant(vol, index):\n        \"\"\"\n        function description\n\n        :param vol:\n\n        :param index:\n        \"\"\"\n\n\n    '''\n    # Volume Tracking\n    class VolTracker:\n        def __init__(self, labware, well_vol,\n                     start=0, end=8,\n                     mode='reagent', pip_type='single',\n                     msg='Reset labware volumes'):\n            \"\"\"Voltracker tracks the volume(s) used in a piece of labware.\n\n            Args:\n                labware: The labware to track\n                well_vol: The volume of the liquid in the wells\n                pip_type: The pipette type used 'single' or 'multi'\n                mode: 'reagent' or 'waste'\n                start: The starting well\n                end: The ending well\n                msg: Message to send to the user when all wells are empty\n\n            \"\"\"\n            self.labware_wells = dict.fromkeys(\n                labware.wells()[start:end], 0)\n            self.labware_wells_backup = self.labware_wells.copy()\n            self.well_vol = well_vol\n            self.pip_type = pip_type\n            self.mode = mode\n            self.start = start\n            self.end = end\n            self.msg = msg\n\n        def tracker(self, vol):\n            \"\"\"\n            Tracker() will track how much liquid was used up per well.\n\n            If the volume of a given well is greater than self.well_vol\n            it will remove it from the dictionary and iterate\n            to the next well which will act as the reservoir.\n            \"\"\"\n            well = next(iter(self.labware_wells))\n            new_well = False\n            if self.labware_wells[well] + vol >= self.well_vol:\n                del self.labware_wells[well]\n                if len(self.labware_wells) < 1:\n                    ctx.pause(self.msg)\n                    self.labware_wells = self.labware_wells_backup.copy()\n                well = next(iter(self.labware_wells))\n                new_well = True\n            if self.pip_type == 'multi':\n                self.labware_wells[well] = self.labware_wells[well] + vol*8\n            elif self.pip_type == 'single':\n                self.labware_wells[well] = self.labware_wells[well] + vol\n            if self.mode == 'waste':\n                ctx.comment(f'''{well}: {int(self.labware_wells[well])} uL of\n                            total waste''')\n            else:\n                ctx.comment(f'''{int(self.labware_wells[well])} uL of liquid\n                            used from {well}''')\n            return well, new_well\n    # reagents\n\n    '''\n    Define where all reagents are on the deck using the labware defined above.\n\n    e.g.\n\n    water = reservoir12.wells()[-1]\n    waste = reservoir.wells()[0]\n    samples = plate.rows()[0][0]\n    dnase = tuberack.wells_by_name()['A4']\n\n    '''\n    ethanol = reservoir.wells_by_name()['A1']\n    water_well = reservoir.wells_by_name()['A2']\n    waste_well = reservoir.wells()[-1]\n    bead_wells = VolTracker(SPRI_bead_plate, bead_source_well_volume, 0, 96)\n\n    mag_plate_sample_wells = barcoded_sample_mag_plate.wells()[0:num_samples]\n    PCR_dest_wells = PCR_destination_plate.wells()[0:num_samples]\n\n    # PCR (super) mastermix is the predefined PCR mastermix + primers\n    # Super-mastermix (smm) total volume could be up to 468 \u00b5L total (36*13)\n    # This would also require an overage of 2*3 rxns = 13*3=39 \u00b5l\n    # Final max volume = 468/200 = 2.34\n    # ceil(2.34)=3, Maximally 3 wells will be needed for SMM\n    PCR_smm_start_well = 9*8+2  # Well C10\n    PCR_smm_end_well = 9*8+4  # Well E10\n\n    # All wells available to make SMM in\n    PCR_smm_wells = \\\n        yourgene_reagent_plate_I.wells()[PCR_smm_start_well:PCR_smm_end_well+1]\n    # Super-mastermix wells that actually contain reagent (to be appended\n    # as smm is made in those wells)\n    PCR_smm_used_wells = []\n\n    PCR_start_well = 80  # A11\n    PCR_end_Well = 96  # H12\n    PCR_mastermix_wells = \\\n        yourgene_reagent_plate_I.wells()[PCR_start_well:PCR_end_Well]\n\n    PCR_primer_start = 9*8  # Well A10\n    PCR_primer_end = 9*8+1  # Well B10\n    PCR_primer_wells = \\\n        yourgene_reagent_plate_I.wells()[PCR_primer_start:PCR_primer_end]\n\n    # plate, tube rack maps\n\n    '''\n    Define any plate or tube maps here.\n\n    e.g.\n\n    plate_wells_by_row = [well for row in plate.rows() for well in row]\n\n    '''\n\n    # protocol\n\n    '''\n\n    Include header sections as follows for each \"section\" of your protocol.\n\n    Section can be defined as a step in a bench protocol.\n\n    e.g.\n\n    ctx.comment('\\n\\nMOVING MASTERMIX TO SAMPLES IN COLUMNS 1-6\\n')\n\n    for .... in ...:\n        ...\n        ...\n\n    ctx.comment('\\n\\nRUNNING THERMOCYCLER PROFILE\\n')\n\n    ...\n    ...\n    ...\n\n\n    '''\n\n    ctx.comment('\\n\\nAdding beads to samples and mixing\\n')\n\n    destination_wells = iter(mag_plate_sample_wells)\n    well_1 = next(destination_wells)\n    bead_well, _ = bead_wells.tracker(25)\n    try:\n        p300.pick_up_tip()\n    except protocol_api.labware.OutOfTipsError:\n        ctx.pause(\"Replace empty tip racks\")\n        p300.reset_tipracks()\n        p300.pick_up_tip()\n    p300.mix(n_bead_solution_mixes, 60, bead_well)\n    p300.aspirate(bead_volume, bead_well)\n    p300.dispense(bead_volume, well_1)\n    p300.mix(n_standard_mixes, 25, well_1)\n    p300.drop_tip()\n\n    for d_well in destination_wells:\n        bead_well, is_new_well = bead_wells.tracker(25)\n        try:\n            p300.pick_up_tip()\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Please replace 200 uL tipracks before continuing\\n\")\n            p300.reset_tipracks()\n            p300.pick_up_tip()\n        if is_new_well:\n            p300.mix(n_bead_solution_mixes, 60, bead_well)\n        p300.aspirate(bead_volume, bead_well)\n        p300.dispense(bead_volume, d_well)\n        p300.mix(n_standard_mixes, 25, d_well)\n        p300.drop_tip()\n\n    ctx.comment(\"\\n\\nRemember to seal bead strips\")\n    ctx.delay(0, 5, \"Incubating samples with beads\")\n    ctx.pause(\"\\n\\nPulse spin plate for 5 seconds\")\n    ctx.comment(\"\\n\\nEngaging magnets\")\n    mag_mod.engage()\n    ctx.delay(0, mag_engage_time, \"binding samples to beads\")\n\n    ctx.comment(\"\\n\\nDiscarding supernatant\")\n    for source_well in mag_plate_sample_wells:\n        try:\n            p300.transfer(50, source_well, waste_well)\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Please replace 200 uL tipracks before continuing\\n\")\n            p300.reset_tipracks()\n            p300.transfer(50, source_well, waste_well)\n\n    # Wash beads in 80 % ethanol x 2\n    for i in range(0, 2):\n        for dest_well in mag_plate_sample_wells:\n            try:\n                p300.transfer(ethanol_wash_vol, ethanol, dest_well)\n            except protocol_api.labware.OutOfTipsError:\n                ctx.pause(\"Please replace 200 uL tipracks before continuing\\n\")\n                p300.reset_tipracks()\n                p300.transfer(ethanol_wash_vol, ethanol, dest_well)\n\n        ctx.delay(30, 0, \"\\n\\nIncubation #{} in 80% EtOH\\n\".format(i+1))\n        for source_well in mag_plate_sample_wells:\n            try:\n                p300.transfer(ethanol_wash_vol, source_well, waste_well)\n            except protocol_api.labware.OutOfTipsError:\n                ctx.pause(\"Please replace 200 uL tipracks before continuing\\n\")\n                p300.reset_tipracks()\n                p300.transfer(ethanol_wash_vol, source_well, waste_well)\n\n    mag_mod.disengage()\n    ctx.pause(\"\\n\\nPulse spin the plate for 5 seconds and replace\\n\")\n\n    # Remove spun-down supernatant\n    mag_mod.engage()\n    ctx.delay(0, mag_engage_time, \"Attracting beads to magnets\")\n    for source_well in mag_plate_sample_wells:\n        try:\n            p300.transfer(ethanol_wash_vol, source_well, waste_well)\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Please replace 200 uL tipracks before continuing\\n\")\n            p300.reset_tipracks()\n            p300.transfer(ethanol_wash_vol, source_well, waste_well)\n\n    ctx.comment(\"\\n\\nAir drying beads\")\n    ctx.delay(0, 5)\n\n    ctx.comment(\"\\n\\nResuspending DNA samples in {} uL of nuc. free water\\n\".\n                format(water_resuspension_vol))\n    # Resuspend DNA/bead samples in water\n    for well in mag_plate_sample_wells:\n        try:\n            p20.pick_up_tip()\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Please replace 20 uL tipracks before continuing\\n\")\n            p20.reset_tipracks()\n            p20.pick_up_tip()\n        p20.aspirate(water_resuspension_vol, water_well)\n        p20.dispense(water_resuspension_vol, well)\n        p20.mix(n_standard_mixes, 10, well)\n        p20.drop_tip()\n\n    ctx.comment(\"Incubating beads in water\")\n    ctx.delay(0, 3)\n    mag_mod.disengage()\n    ctx.pause(\"Pulse spin the sample/bead plate for 5 seconds, then place \" +\n              \"it back on the magnetic module\")\n    ctx.comment(\"Attracting beads\")\n    mag_mod.engage()\n    ctx.delay(0, mag_engage_time)\n\n    # Transfer the bead supernatant to the PCR destination plate\n    ctx.comment(\"\\n\\nTransferring DNA supernatant to PCR plate\")\n    for s_well, d_well in zip(mag_plate_sample_wells, PCR_dest_wells):\n        try:\n            p20.transfer(DNA_supernat_transfer_volume, s_well, d_well)\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Please replace 20 uL tipracks before continuing\\n\")\n            p20.reset_tipracks()\n            p20.transfer(DNA_supernat_transfer_volume, s_well, d_well)\n\n    # Create a PCR (super)mastermix from the PCR mastermix and the primers\n    ctx.comment(\"\\n\\nCreating PCR Mastermix\\n\")\n    # Total volume of PCR mastermix needed for the samples\n    PCR_mm_total_vol = num_samples * PCR_mastermix_vol_per_sample\n    # Total volume of PCR primer mix needed for the samples\n    PCR_primer_total_vol = num_samples * primer_vol_per_sample\n    # Total vol of super-mastermix (mastermix + primer mix) for the samples\n    smm_total_vol = PCR_mm_total_vol + PCR_primer_total_vol\n    # Number of smm reactions that fit into one well\n    smm_rxns_per_well = math.floor(200/PCR_smm_vol_per_sample)\n    # How many wells are needed for the super-mastermix\n    n_super_mm_wells = math.ceil((smm_total_vol)/200)\n    # One excess reaction per smm well to account for any\n    # negative errors in total volume\n    # An overage of two reactions will be created per well\n    n_total_rxns = (math.ceil(smm_total_vol/PCR_smm_vol_per_sample) +\n                    n_super_mm_wells*2)\n\n    PCR_mm_iter = iter(PCR_mastermix_wells)\n    PCR_mm_well = next(PCR_mm_iter)\n    smm_well_iterator = iter(PCR_smm_wells)\n\n    rxns_left = n_total_rxns\n\n    try:\n        p300.pick_up_tip()\n    except protocol_api.labware.OutOfTipsError:\n        ctx.pause(\"Please replace empty 200 uL tipracks\")\n        p300.pick_up_tip()\n    p300.mix(n_standard_mixes, PCR_mm_vol_per_source_well/2, PCR_mm_well)\n    vol_left_in_PCR_mm_well = PCR_mm_vol_per_source_well-1\n\n    try:\n        p20.pick_up_tip()\n    except protocol_api.labware.OutOfTipsError:\n        ctx.pause(\"Please replace empty 20 uL tipracks\")\n        p20.pick_up_tip()\n    p20.mix(n_standard_mixes, 20, PCR_primer_wells[0])\n\n    drop_all_tips()\n\n    # Create smm in as many wells as needed\n    while(rxns_left > 0):\n        d_well = next(smm_well_iterator)\n        n_rxns_this_well = (rxns_left if rxns_left < smm_rxns_per_well\n                            else smm_rxns_per_well)\n        # Transfer PCR mastermixc\n        PCR_mm_vol_this_well = n_rxns_this_well * PCR_mastermix_vol_per_sample\n        while PCR_mm_vol_this_well > 0:\n            if vol_left_in_PCR_mm_well < PCR_mastermix_vol_per_sample:\n                PCR_mm_well = next(PCR_mm_iter)\n                vol_left_in_PCR_mm_well = PCR_mm_vol_per_source_well-1\n                # Mix the well before use\n                try:\n                    p300.pick_up_tip()\n                except protocol_api.labware.OutOfTipsError:\n                    ctx.pause(\"Please replace empty 200 uL tipracks\")\n                    p300.pick_up_tip()\n                p300.mix(n_standard_mixes, PCR_mm_vol_per_source_well/2,\n                         PCR_mm_well)\n                p300.drop_tip()\n            pip = p20 if PCR_mm_vol_this_well < 20 else p300\n            vol = (vol_left_in_PCR_mm_well if PCR_mm_vol_this_well >\n                   vol_left_in_PCR_mm_well else PCR_mm_vol_this_well)\n            if pip.has_tip:\n                pip.drop_tip()\n            try:\n                pip.transfer(vol, PCR_mm_well, d_well)\n            except protocol_api.labware.OutOfTipsError:\n                ctx.pause(\"Please replace empty tipracks before continuing\\n\")\n                pip.reset_tipracks()\n                pip.transfer(vol, PCR_mm_well, d_well)\n            vol_left_in_PCR_mm_well = vol_left_in_PCR_mm_well - vol\n            PCR_mm_vol_this_well = PCR_mm_vol_this_well - vol\n\n        # Transfer primer mix (max primer vol =36*0.5 < primer_vol_per_well)\n        # Therefore we can use one well for everything\n        # Max volume of primer per smm well: 7.5 uL - using the p20 for tfer.\n        primer_transfer_vol = n_rxns_this_well * primer_vol_per_sample\n        p20.transfer(primer_transfer_vol, PCR_primer_wells[0], d_well)\n        rxns_left = rxns_left - n_rxns_this_well\n        PCR_smm_used_wells.append(d_well)\n\n        # Mix the smm\n        vol = (n_rxns_this_well*PCR_smm_vol_per_sample)/2\n        pip = p20 if vol <= 20 else p300\n        try:\n            pip.pick_up_tip()\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Please replace empty tipracks\")\n            pip.pick_up_tip()\n        pip.mix(n_standard_mixes, vol, d_well)\n\n    # Distribute smm to DNA sample wells\n    PCR_smm_tracker = \\\n        VolTracker(yourgene_reagent_plate_I, 200-2*PCR_smm_vol_per_sample,\n                   PCR_smm_start_well,\n                   PCR_smm_start_well+len(PCR_smm_wells),\n                   msg=\"Out of super-mastermix\")\n\n    for d_well in PCR_dest_wells:\n        smm_well, _ = PCR_smm_tracker.tracker(PCR_smm_vol_per_sample)\n        try:\n            p20.pick_up_tip()\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Please replace empty 20 uL tipracks\")\n            p20.pick_up_tip()\n        p20.transfer(PCR_smm_vol_per_sample, smm_well, d_well,\n                     new_tip=\"never\")\n        p20.mix(n_standard_mixes, PCR_sample_total_vol/2, d_well)\n        p20.drop_tip()\n    ctx.comment(\"\\n\\nTransfer the Yourgene cfdna reagent plate I back to \" +\n                \"the freezer\")\n    ctx.comment(\"Pulse spin the PCR sample plate (DP-3) for 5 seconds and \" +\n                \"transfer to the thermocycler and run the cycle \" +\n                \"described in 1.2.47\")\n    ctx.comment(\"\\n\\n~~~ End of protocol part 3 ~~~\")\n",
    "custom_labware_defs": [],
    "fields": [
        {
            "default": 36,
            "label": "Number of samples",
            "name": "num_samples",
            "type": "int"
        },
        {
            "default": 5,
            "label": "Magnetic engagement time when total sample volume < 50 uL",
            "name": "mag_engage_time",
            "type": "int"
        }
    ],
    "instruments": [
        {
            "mount": "left",
            "name": "p20_single_gen2"
        },
        {
            "mount": "right",
            "name": "p300_single_gen2"
        }
    ],
    "labware": [
        {
            "name": "PCR plate on 2",
            "share": false,
            "slot": "2",
            "type": "biorad_96_wellplate_200ul_pcr"
        },
        {
            "name": "Magnetic module sample plate on Magnetic Module GEN2 on 3",
            "share": false,
            "slot": "3",
            "type": "biorad_96_wellplate_200ul_pcr"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 200 \u00b5L on 5",
            "share": false,
            "slot": "5",
            "type": "opentrons_96_filtertiprack_200ul"
        },
        {
            "name": "Reagent reservoir on 6",
            "share": false,
            "slot": "6",
            "type": "nest_12_reservoir_15ml"
        },
        {
            "name": "Reagent Plate - I on 7",
            "share": false,
            "slot": "7",
            "type": "biorad_96_wellplate_200ul_pcr"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 200 \u00b5L on 8",
            "share": false,
            "slot": "8",
            "type": "opentrons_96_filtertiprack_200ul"
        },
        {
            "name": "Magnetic bead plate on 9",
            "share": false,
            "slot": "9",
            "type": "biorad_96_wellplate_200ul_pcr"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 20 \u00b5L on 10",
            "share": false,
            "slot": "10",
            "type": "opentrons_96_filtertiprack_20ul"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 20 \u00b5L on 11",
            "share": false,
            "slot": "11",
            "type": "opentrons_96_filtertiprack_20ul"
        },
        {
            "name": "Opentrons Fixed Trash on 12",
            "share": false,
            "slot": "12",
            "type": "opentrons_1_trash_1100ml_fixed"
        }
    ],
    "metadata": {
        "apiLevel": "2.11",
        "author": "Eskil Andersen <eskil.andersen@opentrons.com>",
        "protocolName": "466f93-3 - Automated LifeCell_NIPT_35Plex_HV",
        "source": "Custom Protocol Request"
    },
    "modules": []
}