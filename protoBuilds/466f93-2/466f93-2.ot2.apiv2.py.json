{
    "content": "\"\"\"Barcoding protocol. 466f93-2 - Automated LifeCell_NIPT_35Plex_HV.\"\"\"\nfrom opentrons import protocol_api\nimport math\n\nmetadata = {\n    'protocolName': '466f93-2 - Automated LifeCell_NIPT_35Plex_HV',\n    'author': 'Eskil Andersen <eskil.andersen@opentrons.com>',\n    'source': 'Custom Protocol Request',\n    'apiLevel': '2.11'   # CHECK IF YOUR API LEVEL HERE IS UP TO DATE\n                         # IN SECTION 5.2 OF THE APIV2 \"VERSIONING\"\n}\n\n\ndef run(ctx: protocol_api.ProtocolContext):\n    \"\"\"Entry point of the protcol.\"\"\"\n    [\n     num_samples,\n     barcode_csv\n    ] = get_values(  # noqa: F821 (<--- DO NOT REMOVE!)\n        \"num_samples\",\n        \"barcode_csv\")\n\n    if not 7 <= num_samples <= 36:\n        raise Exception(\"The number of samples should be between 7 and 36\")\n\n    n_standard_mixes = 10  # Standard number of mixes, 10 in the bench ptcl.\n\n    # define all custom variables above here with descriptions:\n    ALB_vol_per_sample = 2.50  # Addaptor ligation buffer\n    ALB_vol_per_well = 45\n\n    ALE_I_vol_per_sample = 1.50  # Adaptor ligation enzyme I\n    ALE_I_vol_per_well = 27\n\n    ALE_II_vol_per_sample = 0.25  # Adaptor ligation enzyme II\n    ALE_II_vol_per_well = 39\n\n    water_vol_per_sample = 3.75  # Volume of water per sample for AL rxn\n\n    end_repaired_sample_vol = 15  # 15 uL to be mixed with 8 uL mastermix\n    mastermix_vol_per_sample = 8\n\n    barcode_vol_per_sample = 2  # Add 2 uL of barcode to each sample\n\n    csv_rows = barcode_csv.split(\"\\n\")\n\n    # Error checking\n    if not len(csv_rows) == num_samples + 1:\n        raise ValueError((\"Number of samples must match the number of \" +\n                         \"entries in the CSV, csv entries: {}, num_samples: {}\"\n                          ).format(len(csv_rows), num_samples))\n\n    # Barcoding list of lists, n rows x 5 columns\n    # +1 row for the CSV header\n    barcoding_LoL = ([[None]*5 for _ in range(num_samples+1)])\n    barcoding_LoL[0] = csv_rows[0].split(\",\")\n    for csv_row, barcode_row in zip(csv_rows[1:num_samples+1],\n                                    barcoding_LoL[1:]):\n        # dest_well, barcode_well = [int(cell) for cell in csv_row.split(\",\")]\n        row = csv_row.split(\",\")\n        [dest_well, barcode_number, adapter_name,\n         sample_ID, plate_identifier] = [row[0], int(row[1]), row[2], row[3],\n                                         row[4]]\n\n        # Validate the data\n        if (barcode_number < 0 or (barcode_number > 16 and barcode_number < 25)\n                or barcode_number > 56):\n            raise ValueError(\"\"\"The barcode number is invalid (#{})\n                             for sample well #{}. Please correct your CSV\n                             input file.\"\"\".\n                             format(barcode_number, dest_well))\n\n        # Validate that barcode # and plate_number correspond\n        adapter_plate_number = int(plate_identifier.split(\".\")[1])\n        if not barcode_number == adapter_plate_number:\n            raise ValueError((\"The barcode_number ({}) does not match the \" +\n                             \"plate number ({})\").\n                             format(barcode_number, adapter_plate_number))\n\n        barcode_row[0] = dest_well\n        barcode_row[1] = barcode_number\n        barcode_row[2] = adapter_name\n        barcode_row[3] = sample_ID\n        barcode_row[4] = plate_identifier\n\n    # load modules\n\n    '''\n\n    Add your modules here with:\n\n    module_name = ctx.load_module('{module_loadname}', '{slot number}')\n\n    Note: if you are loading a thermocycler, you do not need to specify\n    a slot number - thermocyclers will always occupy slots 7, 8, 10, and 11.\n\n    For all other modules, you can load them on slots 1, 3, 4, 6, 7, 9, 10.\n\n    '''\n    mag_mod = ctx.load_module('magnetic module gen2', '3')\n\n    # load labware\n\n    '''\n\n    Add your labware here with:\n\n    labware_name = ctx.load_labware('{loadname}', '{slot number}')\n\n    If loading labware on a module, you can load with:\n\n    labware_name = module_name.load_labware('{loadname}')\n    where module_name is defined above.\n\n    '''\n    yourgene_reagent_plate_I \\\n        = ctx.load_labware('biorad_96_wellplate_200ul_pcr', '7',\n                           'Yourgene Reagent plate - 1')\n\n    yourgene_reagent_plate_III \\\n        = ctx.load_labware('biorad_96_wellplate_200ul_pcr', '2',\n                           'Yourgene Reagent plate 3 - Barcodes')\n    end_repaired_sample_plate \\\n        = ctx.load_labware('biorad_96_wellplate_200ul_pcr', '1',\n                           'End repaired sample plate (DP-1)')\n    reservoir \\\n        = ctx.load_labware('nest_12_reservoir_15ml', '6',\n                           'Reagent reservoir')\n    destination_plate \\\n        = mag_mod.load_labware('biorad_96_wellplate_200ul_pcr',\n                               'Destination plate 2 (DP-2)')\n\n    # load tipracks\n\n    '''\n\n    Add your tipracks here as a list:\n\n    For a single tip rack:\n\n    tiprack_name = [ctx.load_labware('{loadname}', '{slot number}')]\n\n    For multiple tip racks of the same type:\n\n    tiprack_name = [ctx.load_labware('{loadname}', 'slot')\n                     for slot in ['1', '2', '3']]\n\n    If two different tipracks are on the deck, use convention:\n    tiprack[number of microliters]\n    e.g. tiprack10, tiprack20, tiprack200, tiprack300, tiprack1000\n\n    '''\n    tiprack20s = [ctx.load_labware('opentrons_96_filtertiprack_20ul', slot)\n                  for slot in ['10', '11']]\n    tiprack200s = [ctx.load_labware('opentrons_96_filtertiprack_200ul', slot)\n                   for slot in ['5', '8']]\n\n    # load instrument\n\n    '''\n    Nomenclature for pipette:\n\n    use 'p'  for single-channel, 'm' for multi-channel,\n    followed by number of microliters.\n\n    p20, p300, p1000 (single channel pipettes)\n    m20, m300 (multi-channel pipettes)\n\n    If loading pipette, load with:\n\n    ctx.load_instrument(\n                        '{pipette api load name}',\n                        pipette_mount (\"left\", or \"right\"),\n                        tip_racks=tiprack\n                        )\n    '''\n    p20 = ctx.load_instrument(\"p20_single_gen2\", \"left\", tip_racks=tiprack20s)\n    p300 = ctx.load_instrument(\"p300_single_gen2\", \"right\",\n                               tip_racks=tiprack200s)\n\n    # pipette functions   # INCLUDE ANY BINDING TO CLASS\n\n    '''\n\n    Define all pipette functions, and class extensions here.\n    These may include but are not limited to:\n\n    - Custom pickup functions\n    - Custom drop tip functions\n    - Custom Tip tracking functions\n    - Custom Trash tracking functions\n    - Slow tip withdrawal\n\n    For any functions in your protocol, describe the function as well as\n    describe the parameters which are to be passed in as a docstring below\n    the function (see below).\n\n    def pick_up(pipette):\n        \"\"\"`pick_up()` will pause the protocol when all tip boxes are out of\n        tips, prompting the user to replace all tip racks. Once tipracks are\n        reset, the protocol will start picking up tips from the first tip\n        box as defined in the slot order when assigning the labware definition\n        for that tip box. `pick_up()` will track tips for both pipettes if\n        applicable.\n\n        :param pipette: The pipette desired to pick up tip\n        as definited earlier in the protocol (e.g. p300, m20).\n        \"\"\"\n        try:\n            pipette.pick_up_tip()\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Replace empty tip racks\")\n            pipette.reset_tipracks()\n            pipette.pick_up_tip()\n\n    '''\n    def drop_all_tips():\n        for pip in [p20, p300]:\n            if pip.has_tip:\n                pip.drop_tip()\n\n    # helper functions\n    '''\n    Define any custom helper functions outside of the pipette scope here, using\n    the convention seen above.\n\n    e.g.\n\n    def remove_supernatant(vol, index):\n        \"\"\"\n        function description\n\n        :param vol:\n\n        :param index:\n        \"\"\"\n\n\n    '''\n\n    # reagents\n\n    '''\n    Define where all reagents are on the deck using the labware defined above.\n\n    e.g.\n\n    water = reservoir12.wells()[-1]\n    waste = reservoir.wells()[0]\n    samples = plate.rows()[0][0]\n    dnase = tuberack.wells_by_name()['A4']\n\n    '''\n\n    water_well = reservoir.wells()[1]\n    ALB_I_column = yourgene_reagent_plate_I.columns()[2]\n    ALE_I_column = yourgene_reagent_plate_I.columns()[3]\n    ALE_II_well = yourgene_reagent_plate_I.wells_by_name()['A5']\n    # Mastermix could be up to 288 uL, might need 2 wells\n    mastermix_wells = yourgene_reagent_plate_I.columns()[4][1:3]\n\n    end_repaired_sample_wells = \\\n        end_repaired_sample_plate.wells()[0:num_samples]\n    destination_wells = destination_plate.wells()[0:num_samples]\n\n    # Every other well starting at B6 ending at H9\n    barcodes_plate_I = yourgene_reagent_plate_I.wells()[41:72:2]\n\n    barcodes_plate_III = yourgene_reagent_plate_III.wells()[1:64:2]\n\n    all_barcodes = barcodes_plate_I.copy()\n\n    # There is a gap between plate I and plate II in barcode numbering.\n    # On plate I they end on 16, and on III they begin with 25\n    # Add the in-betweens as empty entries\n    for i in range(17, 25):\n        all_barcodes.append(None)\n\n    for well in barcodes_plate_III:\n        all_barcodes.append(well)\n\n    # plate, tube rack maps\n\n    '''\n    Define any plate or tube maps here.\n\n    e.g.\n\n    plate_wells_by_row = [well for row in plate.rows() for well in row]\n\n    '''\n\n    # protocol\n\n    '''\n\n    Include header sections as follows for each \"section\" of your protocol.\n\n    Section can be defined as a step in a bench protocol.\n\n    e.g.\n\n    ctx.comment('\\n\\nMOVING MASTERMIX TO SAMPLES IN COLUMNS 1-6\\n')\n\n    for .... in ...:\n        ...\n        ...\n\n    ctx.comment('\\n\\nRUNNING THERMOCYCLER PROFILE\\n')\n\n    ...\n    ...\n    ...\n\n\n    '''\n    ctx.comment('\\nCreating Adaptor Ligation Mastermix')\n    # The nastermix is 4 components: water, AL buffer I, AL enzyme I & II\n\n    # Mastermix is put into well B5 and possibly C5 depending on total volume\n    # Each well holds a max of 200 uL. Max volume of mastermix is 296\n    # Each well may hold up to 25 reaction volumes (200/8=25)\n    # There should be one excess MM volume in each well so there's no risk\n    # of any reaction getting less volume than needed.\n\n    n_wells = math.ceil(num_samples/24)\n    mastermix_counter = num_samples\n    ALB_I_iter = iter(ALB_I_column)\n    ALE_I_iter = iter(ALE_I_column)\n    ALE_II_is_mixed = False\n\n    for i in range(0, n_wells):\n        mastermix_multiples = \\\n            (25 if mastermix_counter > 24 else mastermix_counter+1)\n        water_vol = mastermix_multiples * water_vol_per_sample\n        pip = p20 if water_vol <= 20 else p300\n        try:\n            pip.transfer(water_vol, water_well, mastermix_wells[i])\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Replace empty tip racks\")\n            pip.reset_tipracks()\n            pip.transfer(water_vol, water_well, mastermix_wells[i])\n\n        ALB_I_vol = mastermix_multiples * ALB_vol_per_sample\n        ALE_I_vol = mastermix_multiples * ALE_I_vol_per_sample\n\n        # Add AL Buffer I and AL Enzyme I from their source columns\n        for vol, vol_per_well, mix_vol, s_iter \\\n                in zip([ALB_I_vol, ALE_I_vol],\n                       [ALB_vol_per_well, ALE_I_vol_per_well],\n                       [ALB_vol_per_well/2, 20.0],\n                       [ALB_I_iter, ALE_I_iter]):\n            while True:\n                well = next(s_iter)\n                if not p300.has_tip:\n                    try:\n                        p300.pick_up_tip()\n                    except protocol_api.labware.OutOfTipsError:\n                        ctx.pause(\"Replace empty tip racks\")\n                        p300.reset_tipracks()\n                        p300.pick_up_tip()\n                p300.mix(n_standard_mixes, mix_vol, well)\n                if vol > (vol_per_well-1):\n                    p300.transfer(vol_per_well-1, well, mastermix_wells[i],\n                                  new_tip='never')\n                    vol = vol - (vol_per_well-1)\n                else:\n                    pip = p20 if vol <= 20 else p300\n                    if not pip.has_tip:\n                        try:\n                            pip.pick_up_tip()\n                        except protocol_api.labware.OutOfTipsError:\n                            ctx.pause(\"Replace empty tip racks\")\n                            pip.reset_tipracks()\n                            pip.pick_up_tip()\n                    pip.transfer(vol, well, mastermix_wells[i],\n                                 new_tip='never')\n                    drop_all_tips()\n                    break\n\n        # Add Adaptor Ligation Enzyme II to mastermix_wells\n        # Max volume transfer per mastermix well: 0.25 uL * 25 = 6.25 uL\n        ALE_II_vol = mastermix_multiples * ALE_II_vol_per_sample\n        if not ALE_II_is_mixed:\n            try:\n                p20.pick_up_tip()\n            except protocol_api.labware.OutOfTipsError:\n                ctx.pause(\"Replace empty tip racks\")\n                p20.reset_tipracks()\n                p20.pick_up_tip()\n            p20.mix(n_standard_mixes, ALE_II_vol_per_well/2, ALE_II_well)\n            p20.transfer(ALE_II_vol, ALE_II_well, mastermix_wells[i],\n                         new_tip='never')\n            ALE_II_is_mixed = True\n        else:\n            try:\n                p20.transfer(ALE_II_vol, ALE_II_well, mastermix_wells[i])\n            except protocol_api.labware.OutOfTipsError:\n                ctx.pause(\"Replace empty tip racks\")\n                p20.reset_tipracks()\n                p20.pick_up_tip()\n\n        # Mix the mastermix 10x\n        mm_well_volume = 8 * mastermix_multiples\n        pip = p20 if mm_well_volume/2 <= 20 else p300\n        if not pip.has_tip:\n            try:\n                pip.pick_up_tip()\n            except protocol_api.labware.OutOfTipsError:\n                ctx.pause(\"Replace empty tip racks\")\n                pip.reset_tipracks()\n                pip.pick_up_tip()\n        pip.mix(n_standard_mixes, mm_well_volume/2, mastermix_wells[i])\n        drop_all_tips()\n        mastermix_counter = mastermix_counter - 24\n\n    ctx.comment(\"\\n\\nMixing end-repaired samples and AL mastermix\")\n\n    # Transfer mastermix to samples\n    mm_iter = iter(mastermix_wells)\n    n_mastermix_wells = math.ceil(num_samples/24)\n    n_transfers = num_samples\n    try:\n        p20.pick_up_tip()\n    except protocol_api.labware.OutOfTipsError:\n        ctx.pause(\"Replace empty tip racks\")\n        p20.reset_tipracks()\n        p20.pick_up_tip()\n    print(n_mastermix_wells)\n    for i in range(0, n_mastermix_wells):\n        transfers_in_well = 24 if n_transfers >= 24 else n_transfers\n        s_well = next(mm_iter)\n        for j in range(i*24, i*24+transfers_in_well):\n            p20.transfer(mastermix_vol_per_sample, s_well,\n                         destination_wells[j], new_tip='never')\n        n_transfers = n_transfers - transfers_in_well\n    p20.drop_tip()\n\n    ctx.comment(\"\\n\\nTransferring DNA samples\")\n    # Transfer the samples from the end repaired plate to target\n    for s_well, d_well in zip(end_repaired_sample_wells, destination_wells):\n        try:\n            p20.transfer(end_repaired_sample_vol, s_well, d_well)\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Replace empty tip racks\")\n            p20.reset_tipracks()\n            p20.transfer(end_repaired_sample_vol, s_well, d_well)\n\n    # Parse the csv data that defines which barcode well contents gets mixed\n    # with which sample. Data is loaded in csv LoL (list of lists)\n    # where each sub-list contains the sample well number and the barcode\n    # well number\n\n    # The assumption according to the customer is that each barcode well\n    # will be used only once (although the test csv input may have duplicates\n    # since it was auto-generated)\n    for row in barcoding_LoL[1:]:\n        try:\n            # dest_index = int(row[0])-1\n            # dest_well = destination_wells[dest_index]  # -1 bc. array 0-based\n            dest_well = destination_plate.wells_by_name()[row[0]]\n\n            barcode_index = int(row[1])-1\n            barcode_well = all_barcodes[barcode_index]\n        except IndexError:\n            print(row)\n            ctx.comment(\"\"\"Index out of bounds. dest well: {},\n                        barcode index:{}\"\"\".format(row[0], barcode_index))\n        except KeyError:\n            print(row)\n        try:\n            p20.pick_up_tip()\n        except protocol_api.labware.OutOfTipsError:\n            ctx.pause(\"Replace empty tip racks\")\n            p20.reset_tipracks()\n            p20.pick_up_tip()\n        ctx.comment(\"\\nPipetting barcode #{} named {} into sample {} \".\n                    format(row[1], row[2], row[0]))\n        p20.mix(n_standard_mixes, 15, barcode_well)\n        p20.aspirate(barcode_vol_per_sample, barcode_well)\n        p20.dispense(barcode_vol_per_sample,\n                     dest_well)\n        # Last pipetting operation before PCR, so mix the sample wells now\n        p20.mix(n_standard_mixes, 25/2, dest_well)\n        p20.drop_tip()\n\n    ctx.pause(\"\\n\\nPulse spin the destination plate for 5 seconds\")\n    ctx.comment(\"Perform the Adaptor ligation reaction described in 1.2.22\")\n    ctx.comment(\"~~~ End of protocol part 2 ~~~\")\n",
    "custom_labware_defs": [],
    "fields": [
        {
            "default": "DNA_sample_well,barcode_number,Adapter,Sample_ID,plate_number\nA1,1,pmh001a,s1,adapt.01\nB1,2,pmh002a,s2,adapt.02\nC1,3,pmh003a,s3,adapt.03\nD1,4,pmh004a,s4,adapt.04\nE1,5,pmh005a,s5,adapt.05\nF1,6,pmh006a,s6,adapt.06\nG1,7,pmh007a,s7,adapt.07\nH1,8,pmh008a,s8,adapt.08\nA2,9,pmh009a,s9,adapt.09\nB2,10,pmh010a,s10,adapt.10\nC2,11,pmh011a,s11,adapt.11\nD2,12,pmh012a,s12,adapt.12\nE2,13,pmh013a,s13,adapt.13\nF2,14,pmh014a,s14,adapt.14\nG2,15,pmh015a,s15,adapt.15\nH2,16,pmh016a,s16,adapt.16\nA3,25,pmh2001a,s17,adapt.25\nB3,26,pmh2002a,s18,adapt.26\nC3,27,pmh2003a,s19,adapt.27\nD3,28,pmh2004a,s20,adapt.28\nE3,29,pmh2005a,s21,adapt.29\nF3,30,pmh2006a,s22,adapt.30\nG3,31,pmh2007a,s23,adapt.31\nH3,32,pmh2008a,s24,adapt.32\nA4,33,pmh2009a,s25,adapt.33\nB4,34,pmh2010a,s26,adapt.34\nC4,35,pmh2011a,s27,adapt.35\nD4,36,pmh2012a,s28,adapt.36\nE4,37,pmh2013a,s29,adapt.37\nF4,38,pmh2014a,s30,adapt.38\nG4,39,pmh2015a,s31,adapt.39\nH4,40,pmh2016a,s32,adapt.40\nA5,41,pmh2017a,s33,adapt.41\nB5,42,pmh2018a,s34,adapt.42\nC5,43,pmh2019a,s35,adapt.43\nD5,44,pmh2020a,s36,adapt.44",
            "label": "Sample:Barcode Input CSV File",
            "name": "barcode_csv",
            "type": "textFile"
        },
        {
            "default": 36,
            "label": "Number of samples",
            "name": "num_samples",
            "type": "int"
        }
    ],
    "instruments": [
        {
            "mount": "left",
            "name": "p20_single_gen2"
        },
        {
            "mount": "right",
            "name": "p300_single_gen2"
        }
    ],
    "labware": [
        {
            "name": "End repaired sample plate (DP-1) on 1",
            "share": false,
            "slot": "1",
            "type": "biorad_96_wellplate_200ul_pcr"
        },
        {
            "name": "Yourgene Reagent plate 3 - Barcodes on 2",
            "share": false,
            "slot": "2",
            "type": "biorad_96_wellplate_200ul_pcr"
        },
        {
            "name": "Destination plate 2 (DP-2) on Magnetic Module GEN2 on 3",
            "share": false,
            "slot": "3",
            "type": "biorad_96_wellplate_200ul_pcr"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 200 \u00b5L on 5",
            "share": false,
            "slot": "5",
            "type": "opentrons_96_filtertiprack_200ul"
        },
        {
            "name": "Reagent reservoir on 6",
            "share": false,
            "slot": "6",
            "type": "nest_12_reservoir_15ml"
        },
        {
            "name": "Yourgene Reagent plate - 1 on 7",
            "share": false,
            "slot": "7",
            "type": "biorad_96_wellplate_200ul_pcr"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 200 \u00b5L on 8",
            "share": false,
            "slot": "8",
            "type": "opentrons_96_filtertiprack_200ul"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 20 \u00b5L on 10",
            "share": false,
            "slot": "10",
            "type": "opentrons_96_filtertiprack_20ul"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 20 \u00b5L on 11",
            "share": false,
            "slot": "11",
            "type": "opentrons_96_filtertiprack_20ul"
        },
        {
            "name": "Opentrons Fixed Trash on 12",
            "share": false,
            "slot": "12",
            "type": "opentrons_1_trash_1100ml_fixed"
        }
    ],
    "metadata": {
        "apiLevel": "2.11",
        "author": "Eskil Andersen <eskil.andersen@opentrons.com>",
        "protocolName": "466f93-2 - Automated LifeCell_NIPT_35Plex_HV",
        "source": "Custom Protocol Request"
    },
    "modules": []
}