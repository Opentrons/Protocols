{
    "content": "from opentrons.types import Point\nimport json\nimport os\nimport math\n\nmetadata = {\n    'protocolName': 'NucleoMag_RNA_Rev00b',\n    'author': 'Macherey-Nagel <automation-bio@mn-net.com>',\n    'apiLevel': '2.9'\n}\n\n\ndef run(ctx):\n\n    '''\n    Variable definition\n    '''\n    [num_samples, starting_vol, elution_vol, binding_buffer_vol, rDNase_vol,\n     bead_vol, wash1_vol, wash2_vol, wash3_vol, mix_reps_bind, mix_reps_wash,\n     mix_reps_elu, sep_time_bind, sep_time_wash, sep_time_elu, dry_time,\n     tip_track] = get_values(  # noqa: F821\n     \"num_samples\", \"starting_vol\", \"elution_vol\", \"binding_buffer_vol\",\n     \"rDNase_vol\", \"bead_vol\", \"wash1_vol\", \"wash2_vol\", \"wash3_vol\",\n     \"mix_reps_bind\", \"mix_reps_wash\", \"mix_reps_elu\", \"sep_time_bind\",\n     \"sep_time_wash\", \"sep_time_elu\", \"dry_time\", \"tip_track\")\n\n    total_vol_per_sample = starting_vol + (2*binding_buffer_vol) + \\\n        rDNase_vol + wash1_vol + wash2_vol + wash3_vol\n    run_liq_waste_vol = num_samples * total_vol_per_sample\n\n    # Mag_height_elution_plate = 8.5\n\n    Mag_height_SQW = 5.5\n\n    bottom_tolerance = 2.8\n    # Bottom tolerance for aspriation from 12 Well Buffer Reserovir\n\n    '''\n    End of Variable Definition\n    '''\n\n    '''\n    define minimum & maximum volumes\n    '''\n    if not 300 <= starting_vol <= 400:\n        raise Exception('Starting volume should be from 300 - 400\u00b5l.')\n    if not 50 <= elution_vol <= 200:\n        raise Exception('Elution volume should be from 50 - 200\u00b5l.')\n    if not run_liq_waste_vol <= 290000:\n        raise Exception('Number of samples exceeds maximum liquid waste \\\n        volume of 400mL.')\n    if not num_samples <= 48:\n        raise Exception('Number of samples exceeds maximum number of \\\n        48 samples.')\n    '''\n    End of defining minimum & maximum volumes\n    '''\n\n    '''\n    Deck and Labware definition\n    '''\n    magdeck = ctx.load_module('magnetic module gen2', '10')\n    magdeck.disengage()\n    # sep_plate = magdeck.load_labware(\n    #     '96_squarewell_block_macherey_nagel', 'Separation Plate')\n    sep_plate = magdeck.load_labware(\n        'nest_96_wellplate_2ml_deep', 'Separation Plate')\n\n    liquid_waste = ctx.load_labware(\n        'agilent_1_reservoir_290ml', '11', 'Liquid Waste').wells()[0].top()\n\n    # elution_plate = ctx.load_labware(\n    #     '96_elutionplate_ubottom_by_macherey_nagel', '1', 'Elution Plate')\n    elution_plate = ctx.load_labware(\n        'nest_96_wellplate_100ul_pcr_full_skirt', '1', 'Elution Plate')\n\n    tips300 = [\n        ctx.load_labware(\n            'opentrons_96_tiprack_300ul',\n            slot,\n            '300\u00b5l tiprack') for slot in ['2', '3', '5', '6']]\n    tips1000 = ctx.load_labware(\n        'opentrons_96_tiprack_1000ul', '9', '1000\u00b5l tiprack')\n\n    num_cols = math.ceil(num_samples/8)\n\n    parkingrack = ctx.load_labware(\n        'opentrons_96_tiprack_300ul', '8', 'empty tiprack for parking')\n    parking_spots = parkingrack.rows()[0][:num_cols]\n\n    buffers = ctx.load_labware(\n        'usascientific_12_reservoir_22ml', '7', 'NucleoMag Buffers')\n\n    beads = ctx.load_labware(\n        'opentrons_24_tuberack_generic_2ml_screwcap', '4',\n        'NucleoMag B-Beads').wells()[0]\n    # Beads are placed in a single 2mL screwcap tube at A1\n    # Make sure to use max. 1.6mL beads to prevent the tip\n    # from spilling beads when driving down into the tube\n    # because of to high amount in the tube\n\n    '''\n    End of Deck and Labware definition\n    '''\n\n    '''\n    Define reagents\n\n        Well 1 Binding Buffer MR2\n        Well 2 Binding Buffer MR2 for rebinding\n        Well 3 rDNase reaction mix\n        Well 4 & 5 Wash Buffer MR3\n        Well 6, 7 & 8 Wash Buffer MR4\n        Well 9, 10 & 11 Wash Buffer MR4\n        Well 12 Elution Buffer MR5\n\n    '''\n    binding_buffer = buffers.wells()[0]\n    rebind_buffer = buffers.wells()[1]\n    rDNase_mix = buffers.wells()[2]\n    wash1 = buffers.wells()[3:5]\n    wash2 = buffers.wells()[5:8]\n    wash3 = buffers.wells()[8:11]\n    elution_buffer = buffers.wells()[11]\n    '''\n    End of reagent definition\n    '''\n\n    '''\n    tool configuration\n    '''\n    m300 = ctx.load_instrument('p300_multi_gen2', 'left', tip_racks=tips300)\n    s1000 = ctx.load_instrument(\n        'p1000_single_gen2', 'right', tip_racks=[tips1000])\n    '''\n    End of tool configuration\n    '''\n\n    '''\n    Value calculations\n    '''\n    mag_samples_s = sep_plate.wells()[:num_samples]\n    mag_samples_m = sep_plate.rows()[0][:num_cols]\n    elution_samples_m = elution_plate.rows()[0][:num_cols]\n    '''\n    End of Calculations\n    '''\n\n    # sets initial pipetting speeds\n    m300.flow_rate.aspirate = 100\n    m300.flow_rate.dispense = 150\n    m300.flow_rate.blow_out = 200\n\n    s1000.flow_rate.aspirate = 750\n    s1000.flow_rate.dispense = 900\n\n    # define initial pipetting clearance\n    m300.well_bottom_clearance.aspirate = 5\n    m300.well_bottom_clearance.dispense = 25\n\n    '''\n    tip logging and waste handling\n    '''\n    folder_path = '/data/B'\n    tip_file_path = folder_path + '/tip_log.json'\n    tip_log = {'count': {}}\n    if tip_track and not ctx.is_simulating():\n        if os.path.isfile(tip_file_path):\n            with open(tip_file_path) as json_file:\n                data = json.load(json_file)\n                if 'tips300' in data:\n                    tip_log['count'][m300] = data['tips300']\n                else:\n                    tip_log['count'][m300] = 0\n        else:\n            tip_log['count'][m300] = 0\n    else:\n        tip_log['count'] = {m300: 0}\n\n    tip_log['tips'] = {\n        m300: [tip for rack in tips300 for tip in rack.rows()[0]]}\n    tip_log['max'] = {m300: len(tip_log['tips'][m300])}\n\n    # kept _pick_up as default\n    def _pick_up(pip, loc=None):\n        nonlocal tip_log\n        if tip_log['count'][pip] == tip_log['max'][pip] and not loc:\n            ctx.pause(\n                'Replace ' + str(pip.max_volume) + '\u00b5l tipracks before \\\n                resuming.')\n            pip.reset_tipracks()\n            tip_log['count'][pip] = 0\n        if loc:\n            pip.pick_up_tip(loc)\n        else:\n            pip.pick_up_tip(tip_log['tips'][pip][tip_log['count'][pip]])\n            tip_log['count'][pip] += 1\n\n    switch = True\n    drop_count = 0\n    # number of tips trash will accommodate before prompting user to empty\n    drop_threshold = 192\n\n    def _drop(pip):\n        nonlocal switch\n        nonlocal drop_count\n        side = 30 if switch else -18\n        drop_loc = ctx.loaded_labwares[12].wells()[0].top().move(\n            Point(x=side))\n        pip.drop_tip(drop_loc)\n        switch = not switch\n        drop_count += 8\n        if drop_count == drop_threshold:\n            m300.home()\n            ctx.pause('Please empty tips from waste before resuming.')\n\n            ctx.home()  # home before continuing with protocol\n\n            drop_count = 0\n\n    waste_vol = 0\n    waste_threshold = 300000\n\n    '''\n    End of tip logging and wase handling\n    '''\n\n    def remove_supernatant(\n            vol, reuse=False, restore=False, last=False, blowout=True):\n\n        \"\"\"\n        `remove_supernatant` will transfer supernatant from the deepwell\n        extraction plate to the liquid waste reservoir.\n        :param vol (float): The amount of volume to aspirate from all deepwell\n                            sample wells and dispense in the liquid waste.\n        :param reuse (boolean): Whether to pick up previously restored\n                                sample-corresponding tips from the\n                                'parking rack' or to pick up new tips.\n        :param restore (boolean): Whether to park used tips in the\n                                  'parking rack' or discard them to waste.\n        :param last (boolean): Does perform the supernatant removal at the\n                               lowest hight possible with an extra over\n                               aspiration volume for the last wash step to\n                               optimize drying performance\n        \"\"\"\n\n        def _waste_track(vol):\n            nonlocal waste_vol\n            if waste_vol + vol >= waste_threshold:\n                ctx.pause('Please empty liquid waste (slot 11) before \\\n                resuming.')\n                ctx.home()\n                waste_vol = 0\n            waste_vol += vol\n        if last:\n            vol = vol + 60\n        num_trans = math.ceil(vol/200)\n        vol_per_trans = vol/num_trans\n        m300.flow_rate.aspirate = 24\n        m300.flow_rate.dispense = 120\n\n        for i, (m, spot) in enumerate(zip(mag_samples_m, parking_spots)):\n            if reuse:\n                _pick_up(m300, spot)\n            else:\n                _pick_up(m300)\n            side = -1 if i % 2 == 0 else 1\n            # position modifier to aspirate away from the bead pellet\n            for _ in range(num_trans):\n                _waste_track(vol_per_trans*8)\n                if m300.current_volume > 0:\n                    m300.dispense(m300.current_volume, m.top(-10))\n                m300.move_to(m.center())\n                if _ == num_trans-1:\n                    if last:\n                        loc = m.bottom(0.7).move(Point(x=side*0.5))\n                    else:\n                        loc = m.bottom(0.8).move(Point(x=side*0.7))\n                else:\n                    loc = m.bottom(1.0).move(Point(x=side*1))\n\n                m300.transfer(\n                    vol_per_trans, loc, liquid_waste, new_tip='never',\n                    air_gap=20)\n\n                if _ == num_trans-1:\n                    if blowout:\n                        m300.blow_out(liquid_waste)\n                        m300.aspirate(20, liquid_waste)\n                else:\n                    if blowout:\n                        m300.blow_out(liquid_waste)\n                    m300.aspirate(20, liquid_waste)\n                # m300.air_gap(20)\n                # extra removal in last wash step to remove residual ethanol\n            if last:\n                m300.aspirate(20, m.bottom(0.6))\n                m300.aspirate(20, m.bottom(0.7))\n                m300.aspirate(20, m.bottom(0.8))\n                m300.dispense(m300.current_volume, liquid_waste)\n                m300.aspirate(20, liquid_waste)\n            if restore:\n                m300.drop_tip(spot)\n            else:\n                _drop(m300)\n        m300.flow_rate.aspirate = 90\n        m300.flow_rate.dispense = 150\n\n    def bind(vol, bead_vol, reuse=True, restore=False):\n        \"\"\"\n        `bind` will perform magnetic bead binding on each sample in the\n        deepwell plate. The binding beads will be mixed before\n        transfer (with s1000 tool), and the samples will be mixed\n        with the binding beads after the transfer (with m300 tool).\n        The magnetic deck activates after the addition to all\n        samples, and the supernatant is removed after bead binding.\n        :param vol (float): Amount of volume of Binding Buffer\n        to add to each well.\n        :param bead_vol (float): The amount of volume of NucleoMag B-Beads\n        to dispense to each well.\n        :param reuse (boolean): Whether to save sample-corresponding tips\n                               between adding binding buffer and\n                               removing the supernatant\n        :param restore (boolean): Whether to save sample-corresponding tips for\n        reuse in the next stepre\n        \"\"\"\n        if magdeck.status == 'engaged':\n            magdeck.disengage()\n\n        # Multidispense loop for distributing beads\n\n        bead_aspirate_vol_total = num_samples * bead_vol + 50\n        if bead_aspirate_vol_total >= 800:\n            bead_aspirate_vol = bead_aspirate_vol_total/2\n        else:\n            bead_aspirate_vol = bead_aspirate_vol_total\n\n        bead_mix_vol_temp = num_samples * bead_vol\n        if bead_mix_vol_temp >= 900:\n            bead_mix_vol = 900\n        else:\n            bead_mix_vol = bead_mix_vol_temp - 100\n\n        air_gap_vol = 20\n        bead_dispense_vol = bead_vol + air_gap_vol\n\n        # Mix loop to resuspend beads\n        s1000.pick_up_tip()\n        for x in range(3):\n            s1000.aspirate(bead_mix_vol, beads.bottom(5))\n            s1000.dispense(bead_mix_vol, beads.bottom(5))\n        for x in range(7):\n            s1000.aspirate(bead_mix_vol, beads.bottom(3))\n            s1000.dispense(bead_mix_vol, beads.bottom(3))\n\n        s1000.aspirate(bead_aspirate_vol, beads.bottom(3))\n        s1000.air_gap(air_gap_vol)\n        s1000.flow_rate.dispense = 1000\n        for loop, (well) in enumerate(mag_samples_s):\n            if loop == 24:\n                s1000.aspirate(bead_aspirate_vol, beads.bottom(3))\n            s1000.dispense(bead_dispense_vol, well.top(-2))\n            s1000.air_gap(air_gap_vol)\n\n        s1000.dispense(50, beads.bottom(10))\n        s1000.drop_tip()\n        # End of bead dispense\n\n        for i, (well, spot) in enumerate(zip(mag_samples_m, parking_spots)):\n            _pick_up(m300)\n            num_trans = math.ceil(vol/200)\n            vol_per_trans = vol/num_trans\n            m300.flow_rate.aspirate = 100\n            for t in range(num_trans):\n                # src = binding_buffer[i//(10//len(binding_buffer))]\n                src = binding_buffer\n                if m300.current_volume > 0:\n                    m300.dispense(m300.current_volume, src.top())\n                m300.aspirate(vol_per_trans, src.bottom(bottom_tolerance))\n                m300.aspirate(20, src.top(2))\n                ctx.delay(seconds=5, msg='drop delay')\n                m300.dispense(vol_per_trans+20, well.top(-3))\n                # m300.transfer(\n                #     vol_per_trans, src.bottom(bottom_tolerance),\n                #     well.top(-3), air_gap=20, new_tip='never')\n                if t < num_trans - 1:\n                    m300.air_gap(20)\n            side = 1 if i % 2 == 0 else -1\n            # l oc_mix = well.bottom(1.5).move(Point(x=side*0.8))\n            loc_mix_asp_bottom = well.bottom(2)\n            loc_mix_asp_top = well.bottom(5)\n            loc_mix_dis_bottom = well.bottom(1)\n            loc_mix_dis_pellet = well.bottom(1.5).move(Point(x=side*0.8))\n            loc_mix_dis_top = well.bottom(15)\n            # maybe split into two mix pos.\n            # one directly over the bead pellet for the first 4-5 cycles\n            # a second one higher in the liquid column to\n            # distribute the beads during the later mix cycles)\n            # m300.mix(mix_reps_bind, 200, loc_mix)\n            ''' optimized mix '''\n\n            m300.flow_rate.aspirate = 60\n            m300.flow_rate.dispense = 300\n            # resuspend at pellet\n            for x in range(10):\n                m300.aspirate(250, loc_mix_asp_top)\n                m300.dispense(250, loc_mix_dis_pellet)\n            # resuspend beads across the entire liquid column\n            for x in range(2):\n                m300.aspirate(200, loc_mix_asp_top)\n                m300.dispense(200, loc_mix_dis_bottom)\n            m300.flow_rate.aspirate = 150\n            for x in range(mix_reps_bind-7):\n                m300.aspirate(250, loc_mix_asp_bottom)\n                m300.dispense(250, loc_mix_dis_top)\n            m300.flow_rate.aspirate = 100\n            m300.flow_rate.dispense = 200\n            ''' end of optimized mix '''\n            # aspirate and dispense 1\u00b5L at top(-10),\n            # is there a ctx.move command?\n            m300.aspirate(15, well.top(-10))\n            ctx.delay(seconds=3, msg='Blow out delay')\n            m300.dispense(15, well.top(-10))\n            m300.blow_out(well.bottom(22))\n            m300.air_gap(5)\n            if reuse:\n                m300.drop_tip(spot)\n            else:\n                _drop(m300)\n\n        ctx.delay(minutes=2, msg='Incubate for 2 minutes')\n        magdeck.engage(height=Mag_height_SQW)\n        ctx.delay(\n            minutes=sep_time_bind,\n            msg='Incubating on MagDeck for '+str(sep_time_bind)+' minutes.')\n\n        # remove initial supernatant\n        remove_supernatant(\n            vol+bead_vol+starting_vol,\n            reuse=reuse, restore=restore, last=True)\n\n    def rDNase_digest(rDNase_vol, rebind_vol, reuse=True, restore=False):\n        \"\"\"\n        `rDNase_digest` will perform a DNase digestion of the DNA bound to the\n        magnetic beads followed by a rebinding auf RNA to the magnetic beads.\n        :param rDNase_vol (float): Amount of volume of rDNase reaction mix to\n        add to each well.\n        :param rebind_vol (float): The amount of MR2 buffer to dispense to each\n        well. Typically equal to initial binding volume of MR2\n        :param reuse (boolean): Whether to save sample-corresponding tips\n                               between adding binding buffer and removing\n                               the supernatant\n        :param restore (boolean): Whether to save sample-corresponding tips for\n        reuse in the next stepre\n        \"\"\"\n        ctx.delay(minutes=20, msg='Dr before rDNase digest')\n        if magdeck.status == 'engaged':\n            magdeck.disengage()\n\n        working_vol = rDNase_vol + rebind_vol\n\n        for i, (well, spot) in enumerate(zip(mag_samples_m, parking_spots)):\n            _pick_up(m300)\n            num_trans = math.ceil(rDNase_vol/200)\n            vol_per_trans = rDNase_vol/num_trans\n            m300.flow_rate.aspirate = 100\n            for t in range(num_trans):\n                if m300.current_volume > 0:\n                    m300.dispense(m300.current_volume, rDNase_mix.top())\n                m300.aspirate(\n                    vol_per_trans, rDNase_mix.bottom(bottom_tolerance))\n                m300.aspirate(20, rDNase_mix.top(2))\n                ctx.delay(seconds=5, msg='drop delay')\n                m300.dispense(vol_per_trans+20, well.top(-3))\n                # m300.transfer(\n                #     vol_per_trans, src.bottom(bottom_tolerance),\n                #     well.top(-3), air_gap=20, new_tip='never')\n                if t < num_trans - 1:\n                    m300.air_gap(20)\n            side = 1 if i % 2 == 0 else -1\n            loc_mix_asp_bottom = well.bottom(2)\n            loc_mix_asp_top = well.bottom(3)\n            # loc_mix_dis_bottom = well.bottom(1)\n            loc_mix_dis_pellet = well.bottom(1.5).move(Point(x=side*0.8))\n            loc_mix_dis_top = well.bottom(15)\n            ''' optimized mix '''\n\n            m300.flow_rate.aspirate = 60\n            m300.flow_rate.dispense = 300\n            # resuspend at pellet\n            for x in range(10):\n                m300.aspirate(250, loc_mix_asp_top)\n                m300.dispense(250, loc_mix_dis_pellet)\n            m300.flow_rate.aspirate = 150\n            for x in range(mix_reps_bind-5):\n                m300.aspirate(250, loc_mix_asp_bottom)\n                m300.dispense(250, loc_mix_dis_top)\n            m300.flow_rate.aspirate = 100\n            m300.flow_rate.dispense = 200\n            ''' end of optimized mix '''\n            m300.aspirate(15, well.top(-10))\n            ctx.delay(seconds=3, msg='Blow out delay')\n            m300.dispense(15, well.top(-10))\n            m300.blow_out(well.bottom(22))\n            m300.air_gap(5)\n            _drop(m300)\n\n        ctx.delay(minutes=15, msg='Incubate for 15 minutes DNase digest')\n\n        # start rebinding\n        for i, (well, spot) in enumerate(zip(mag_samples_m, parking_spots)):\n            _pick_up(m300)\n            num_trans = math.ceil(rebind_vol/200)\n            vol_per_trans = rebind_vol/num_trans\n            m300.flow_rate.aspirate = 100\n            for t in range(num_trans):\n                if m300.current_volume > 0:\n                    m300.dispense(m300.current_volume, rDNase_mix.top())\n                m300.aspirate(\n                    vol_per_trans, rebind_buffer.bottom(bottom_tolerance))\n                m300.aspirate(20, rebind_buffer.top(2))\n                ctx.delay(seconds=5, msg='drop delay')\n                m300.dispense(vol_per_trans+20, well.top(-3))\n                # m300.transfer(\n                #     vol_per_trans, src.bottom(bottom_tolerance),\n                #     well.top(-3), air_gap=20, new_tip='never')\n                if t < num_trans - 1:\n                    m300.air_gap(20)\n            side = 1 if i % 2 == 0 else -1\n            loc_mix_asp_bottom = well.bottom(2)\n            loc_mix_asp_top = well.bottom(5)\n            # loc_mix_dis_bottom = well.bottom(1)\n            loc_mix_dis_pellet = well.bottom(1.5).move(Point(x=side*0.8))\n            loc_mix_dis_top = well.bottom(15)\n            ''' optimized mix '''\n\n            m300.flow_rate.aspirate = 60\n            m300.flow_rate.dispense = 300\n            # resuspend at pellet\n            for x in range(10):\n                m300.aspirate(250, loc_mix_asp_top)\n                m300.dispense(250, loc_mix_dis_pellet)\n            m300.flow_rate.aspirate = 150\n            for x in range(mix_reps_bind-5):\n                m300.aspirate(250, loc_mix_asp_bottom)\n                m300.dispense(250, loc_mix_dis_top)\n            m300.flow_rate.aspirate = 100\n            m300.flow_rate.dispense = 200\n            ''' end of optimized mix '''\n            m300.aspirate(15, well.top(-10))\n            ctx.delay(seconds=3, msg='Blow out delay')\n            m300.dispense(15, well.top(-10))\n            m300.blow_out(well.bottom(22))\n            m300.air_gap(5)\n            if reuse:\n                m300.drop_tip(spot)\n            else:\n                _drop(m300)\n\n        ctx.delay(minutes=2, msg='Incubate for 2 minutes')\n        magdeck.engage(height=Mag_height_SQW)\n        ctx.delay(\n            minutes=sep_time_bind,\n            msg='Incubating on MagDeck for '+str(sep_time_bind)+' minutes.')\n\n        # remove initial supernatant\n        remove_supernatant(\n            working_vol, reuse=reuse, restore=restore, last=False)\n\n    def wash(\n            vol, source, mix_reps=mix_reps_wash, reuse=True, restore=True,\n            resuspend=True, last=False, blowout=True):\n        \"\"\"\n        `wash` will perform bead washing for the extraction protocol.\n        :param vol (float): The amount of volume to aspirate from each\n                            source and dispense to each well containing beads.\n        :param source (List[Well]): A list of wells from where liquid will be\n                                    aspirated. If the length of the source list\n                                    > 1, `wash` automatically calculates\n                                    the index of the source that should be\n                                    accessed.\n        :param mix_reps (int): The number of repititions to mix the beads with\n                               specified wash buffer (ignored if resuspend is\n                               False).\n        :param reuse (boolean): Whether to pick-up sample-corresponding tips\n        for mixing and supernatant removal that were restored in previous steps\n        :param restore (boolean): Whether to park sample-corresponding tips for\n        reuse in a later step\n        :param resuspend (boolean): Whether to resuspend beads in wash buffer.\n        \"\"\"\n\n        if resuspend and magdeck.status == 'engaged':\n            magdeck.disengage()\n\n        num_trans = math.ceil(vol/250)\n        vol_per_trans = vol/num_trans\n\n        # Dispense with fresh tips & mix with restored tips from previous step\n        if reuse:\n            _pick_up(m300)\n            for i, (m) in enumerate(mag_samples_m):\n                src = source[i//(10//len(source))]\n                for n in range(num_trans):\n                    if m300.current_volume > 0:\n                        m300.dispense(m300.current_volume, src.top())\n                    m300.aspirate(vol_per_trans, src.bottom(bottom_tolerance))\n                    m300.aspirate(20, src.top(2))\n                    ctx.delay(seconds=5, msg='drop delay')\n                    m300.dispense(vol_per_trans+20, m.top())\n                    # m300.transfer(\n                    #     vol_per_trans, src.bottom(bottom_tolerance),\n                    #     m.top(), air_gap=20, new_tip='never')\n                    if n < num_trans - 1:  # only air_gap if going back to src\n                        m300.air_gap(20)\n            _drop(m300)\n            if resuspend:\n                m300.flow_rate.aspirate = 220\n                m300.flow_rate.dispense = 300\n                for i, (m, spot) in enumerate(\n                        zip(mag_samples_m, parking_spots)):\n                    _pick_up(m300, spot)\n                    side = 1 if i % 2 == 0 else -1\n                    # loc_mix = m.bottom(2).move(Point(x=side*1.5))\n                    ''' new mix locations '''\n                    loc_mix_asp_bottom = m.bottom(1.5)\n                    loc_mix_asp_top = m.bottom(5)\n                    loc_mix_dis_pellet = m.bottom(1.5).move(Point(x=side*0.8))\n                    loc_mix_dis_top = m.bottom(12)\n                    ''' end of new mix locations '''\n                    src = source[i//(10//len(source))]\n                    # for rep in range(mix_reps):\n                    #     m300.aspirate(250, loc_mix)\n                    #     m300.dispense(250, loc_mix)\n                    ''' optimized mix '''\n                    # resuspend at pellet\n                    for x in range(10):\n                        m300.aspirate(250, loc_mix_asp_top)\n                        m300.dispense(250, loc_mix_dis_pellet)\n                    # resuspend beads across the entire liquid column\n                    for x in range(mix_reps-5):\n                        m300.aspirate(250, loc_mix_asp_bottom)\n                        m300.dispense(250, loc_mix_dis_top)\n                    ''' end of optimized mix '''\n                    m300.blow_out(m.bottom(13))\n                    m300.air_gap(20)\n                    m300.drop_tip(spot)\n                m300.flow_rate.aspirate = 100\n                m300.flow_rate.dispense = 200\n        else:  # Dispense & mix with fresh tips\n            for i, (m, spot) in enumerate(zip(mag_samples_m, parking_spots)):\n                _pick_up(m300)\n                side = 1 if i % 2 == 0 else -1\n                # loc_mix = m.bottom(2).move(Point(x=side*1.5))\n                ''' new mix locations '''\n                loc_mix_asp_bottom = m.bottom(1.5)\n                loc_mix_asp_top = m.bottom(5)\n                loc_mix_dis_bottom = m.bottom(1)\n                loc_mix_dis_pellet = m.bottom(1.5).move(Point(x=side*0.8))\n                loc_mix_dis_top = m.bottom(12)\n                ''' end of new mix locations '''\n                src = source[i//(10//len(source))]\n                for n in range(num_trans):\n                    if m300.current_volume > 0:\n                        m300.dispense(m300.current_volume, src.top())\n                    m300.transfer(\n                        vol_per_trans, src.bottom(bottom_tolerance),\n                        m.top(), air_gap=20, new_tip='never')\n                    if n < num_trans - 1:  # only air_gap if going back to src\n                        m300.air_gap(20)\n                if resuspend:\n                    m300.flow_rate.aspirate = 80\n                    m300.flow_rate.dispense = 300\n                    # for rep in range(mix_reps):\n                    #     m300.aspirate(250, loc_mix)\n                    #     m300.dispense(250, loc_mix)\n                    ''' optimized mix '''\n                    # resuspend at pellet\n                    for x in range(10):\n                        m300.aspirate(250, loc_mix_asp_top)\n                        m300.dispense(250, loc_mix_dis_pellet)\n                    for x in range(2):\n                        m300.aspirate(200, loc_mix_asp_top)\n                        m300.dispense(200, loc_mix_dis_bottom)\n                    # resuspend beads across the entire liquid column\n                    for x in range(mix_reps-7):\n                        m300.aspirate(250, loc_mix_asp_bottom)\n                        m300.dispense(250, loc_mix_dis_top)\n                    ''' end of optimized mix '''\n                    m300.flow_rate.aspirate = 120\n                    m300.flow_rate.dispense = 200\n                m300.blow_out(m.bottom(13))\n                m300.air_gap(20)\n                m300.drop_tip(spot)\n\n        if magdeck.status == 'disengaged':\n            magdeck.engage(height=Mag_height_SQW)\n\n        ctx.delay(\n            minutes=sep_time_wash,\n            msg='Incubating on MagDeck for '+str(sep_time_wash)+' minutes.')\n\n        remove_supernatant(\n            vol, reuse=True, restore=restore, last=last, blowout=blowout)\n\n    def elute(vol):\n        \"\"\"\n        `elute` will perform elution from the deepwell extraciton plate to the\n        final clean elutions PCR plate to complete the extraction protocol.\n        :param vol (float): The amount of volume to aspirate from the elution\n                            buffer source and dispense to each well containing\n                            beads.\n        \"\"\"\n\n        magdeck.disengage()\n        for i, (m) in enumerate(mag_samples_m):\n            _pick_up(m300)\n            side = 1 if i % 2 == 0 else -1\n            loc_mix_asp_bottom = m.bottom(1.2)\n            loc_mix_dis_pellet = m.bottom(1.5).move(Point(x=side*1.5))\n            m300.aspirate(vol, elution_buffer.bottom(bottom_tolerance))\n            m300.move_to(m.center())\n            m300.dispense(vol, loc_mix_dis_pellet)\n            m300.flow_rate.aspirate = 220\n            m300.flow_rate.dispense = 300\n            for mix in range(mix_reps_elu):\n                m300.aspirate(0.8*vol, loc_mix_asp_bottom)\n                m300.dispense(0.8*vol, loc_mix_dis_pellet)\n            m300.flow_rate.aspirate = 60\n            m300.flow_rate.dispense = 100\n            m300.blow_out(m.bottom(7))\n            m300.air_gap(20)\n            _drop(m300)\n\n        magdeck.engage(height=Mag_height_SQW)\n        ctx.delay(\n            minutes=sep_time_elu,\n            msg='Incubating on MagDeck for '+str(sep_time_elu)+' minutes.')\n\n        m300.flow_rate.aspirate = 30\n\n        for i, (m, e) in enumerate(zip(mag_samples_m, elution_samples_m)):\n            _pick_up(m300)\n            side = -1 if i % 2 == 0 else 1\n            loc = m.bottom(0.9).move(Point(x=side*0.8))\n            m300.transfer(vol, loc, e.bottom(5), air_gap=20, new_tip='never')\n\n            m300.blow_out(e.top(-1))\n            m300.air_gap(10)\n            m300.drop_tip()\n\n        magdeck.disengage()\n\n    \"\"\"\n    Here is where you can call the methods defined above to fit your specific\n    protocol. The normal sequence is:\n    \"\"\"\n    bind(binding_buffer_vol, bead_vol, reuse=True, restore=False)\n    rDNase_digest(rDNase_vol, binding_buffer_vol, reuse=True, restore=False)\n\n    wash(\n        wash1_vol, wash1, reuse=False,\n        restore=False, resuspend=True, last=False, blowout=False)\n    wash(\n        wash2_vol, wash2, reuse=False,\n        restore=False, resuspend=True, last=False, blowout=False)\n    wash(\n        wash3_vol, wash3, reuse=False,\n        restore=False, resuspend=True, last=True, blowout=False)\n\n    ctx.delay(minutes=dry_time, msg='Air dry')\n\n    elute(elution_vol)\n\n    # track final used tip\n    if tip_track and not ctx.is_simulating():\n        if not os.path.isdir(folder_path):\n            os.mkdir(folder_path)\n        data = {'tips300': tip_log['count'][m300]}\n        with open(tip_file_path, 'w') as outfile:\n            json.dump(data, outfile)\n",
    "custom_labware_defs": [],
    "fields": [
        {
            "default": 48,
            "label": "Number of Samples [1-48]",
            "name": "num_samples",
            "type": "int"
        },
        {
            "default": 350,
            "label": "Starting Volume [Scale this volume proportionally to other volumes]",
            "name": "starting_vol",
            "type": "int"
        },
        {
            "default": 100,
            "label": "Elution Volume [50-200\u00b5L]",
            "name": "elution_vol",
            "type": "int"
        },
        {
            "default": 350,
            "label": "Binding Buffer Volume [Scale this volume proportionally to other volumes]",
            "name": "binding_buffer_vol",
            "type": "int"
        },
        {
            "default": 300,
            "label": "rDNase Volume [Scale this volume proportionally to other volumes]",
            "name": "rDNase_vol",
            "type": "int"
        },
        {
            "default": 28,
            "label": "Bead Volume [Scale this volume proportionally to other volumes]",
            "name": "bead_vol",
            "type": "int"
        },
        {
            "default": 600,
            "label": "Wash 1 Volume [Scale this volume proportionally to other volumes]",
            "name": "wash1_vol",
            "type": "int"
        },
        {
            "default": 900,
            "label": "Wash 2 Volume [Scale this volume proportionally to other volumes]",
            "name": "wash2_vol",
            "type": "int"
        },
        {
            "default": 900,
            "label": "Wash 3 Volume [Scale this volume proportionally to other volumes]",
            "name": "wash3_vol",
            "type": "int"
        },
        {
            "default": 25,
            "label": "Mix Repetitions during Binding [pretested default, changing is not recommended]",
            "name": "mix_reps_bind",
            "type": "int"
        },
        {
            "default": 20,
            "label": "Mix Repetitions during Wash [pretested default, changing is not recommended]",
            "name": "mix_reps_wash",
            "type": "int"
        },
        {
            "default": 25,
            "label": "Mix Repetitions during Elution [pretested default, changing is not recommended]",
            "name": "mix_reps_elu",
            "type": "int"
        },
        {
            "default": 5,
            "label": "Separation Time during Binding [pretested default, changing is not recommended]",
            "name": "sep_time_bind",
            "type": "int"
        },
        {
            "default": 2,
            "label": "Separation Time during Wash [pretested default, changing is not recommended]",
            "name": "sep_time_wash",
            "type": "int"
        },
        {
            "default": 30,
            "label": "Time for Air Dry [pretested default, changing is not recommended]",
            "name": "dry_time",
            "type": "int"
        },
        {
            "default": 5,
            "label": "Separation Time during Elution [pretested default, changing is not recommended]",
            "name": "sep_time_elu",
            "type": "int"
        },
        {
            "label": "Track Tips Between Runs",
            "name": "tip_track",
            "options": [
                {
                    "label": "No",
                    "value": 0
                },
                {
                    "label": "Yes",
                    "value": 1
                }
            ],
            "type": "dropDown"
        }
    ],
    "instruments": [
        {
            "mount": "left",
            "name": "p300_multi_gen2"
        },
        {
            "mount": "right",
            "name": "p1000_single_gen2"
        }
    ],
    "labware": [
        {
            "name": "Elution Plate on 1",
            "share": false,
            "slot": "1",
            "type": "nest_96_wellplate_100ul_pcr_full_skirt"
        },
        {
            "name": "300\u00b5l tiprack on 2",
            "share": false,
            "slot": "2",
            "type": "opentrons_96_tiprack_300ul"
        },
        {
            "name": "300\u00b5l tiprack on 3",
            "share": false,
            "slot": "3",
            "type": "opentrons_96_tiprack_300ul"
        },
        {
            "name": "NucleoMag B-Beads on 4",
            "share": false,
            "slot": "4",
            "type": "opentrons_24_tuberack_generic_2ml_screwcap"
        },
        {
            "name": "300\u00b5l tiprack on 5",
            "share": false,
            "slot": "5",
            "type": "opentrons_96_tiprack_300ul"
        },
        {
            "name": "300\u00b5l tiprack on 6",
            "share": false,
            "slot": "6",
            "type": "opentrons_96_tiprack_300ul"
        },
        {
            "name": "NucleoMag Buffers on 7",
            "share": false,
            "slot": "7",
            "type": "usascientific_12_reservoir_22ml"
        },
        {
            "name": "empty tiprack for parking on 8",
            "share": false,
            "slot": "8",
            "type": "opentrons_96_tiprack_300ul"
        },
        {
            "name": "1000\u00b5l tiprack on 9",
            "share": false,
            "slot": "9",
            "type": "opentrons_96_tiprack_1000ul"
        },
        {
            "name": "Separation Plate on Magnetic Module GEN2 on 10",
            "share": false,
            "slot": "10",
            "type": "nest_96_wellplate_2ml_deep"
        },
        {
            "name": "Liquid Waste on 11",
            "share": false,
            "slot": "11",
            "type": "agilent_1_reservoir_290ml"
        },
        {
            "name": "Opentrons Fixed Trash on 12",
            "share": false,
            "slot": "12",
            "type": "opentrons_1_trash_1100ml_fixed"
        }
    ],
    "metadata": {
        "apiLevel": "2.9",
        "author": "Macherey-Nagel <automation-bio@mn-net.com>",
        "protocolName": "NucleoMag_RNA_Rev00b"
    },
    "modules": [
        {
            "name": "MagneticModuleContext at Magnetic Module GEN2 on 10 lw Separation Plate on Magnetic Module GEN2 on 10",
            "share": false,
            "slot": "10",
            "type": "magdeck"
        }
    ]
}