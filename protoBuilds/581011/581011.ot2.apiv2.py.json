{
    "content": "\"\"\"PROTOCOL.\"\"\"\nfrom itertools import groupby\nimport math\n\nmetadata = {\n    'protocolName': 'Cherrypicking with Multi-Channel Pipette and CSV',\n    'author': 'Rami Farawi <rami.farawi@opentrons.com>',\n    'source': 'Custom Protocol Request',\n    'apiLevel': '2.10'\n}\n\n\ndef run(ctx):\n    \"\"\"PROTOCOL.\"\"\"\n    [csv_samp] = get_values(  # noqa: F821\n        \"csv_samp\")\n\n    fields = [[val.strip() for val in line.split(',')][1:]\n              for line in csv_samp.splitlines()\n              if line.split(',')[0].strip()][17:19]\n\n    day1 = fields[0]\n    vol_target_cell = int(day1[0])\n    pre_mix = day1[1].lower().startswith(\"yes\")\n    mix_asp_height = float(day1[2])\n    mix_disp_height = float(day1[3])\n    premix_reps = int(day1[4])\n    mix_vol = int(day1[5])\n    mix_rate = float(day1[6])\n    disp_res_height = float(day1[7])\n    asp_height = float(day1[8])\n    disp_height = float(day1[9])\n    asp_rate = float(day1[10])\n    disp_rate = float(day1[11])\n    m300_mount = day1[12]\n\n    # load labware\n    plate = ctx.load_labware('corning_384_wellplate_112ul_flat', '4')\n    target_res = ctx.load_labware('nest_12_reservoir_15ml', '5')\n    tiprack = [ctx.load_labware('opentrons_96_filtertiprack_200ul', slot)\n               for slot in ['6']]\n\n    # load instrument\n    m300 = ctx.load_instrument('p300_multi_gen2', m300_mount,\n                               tip_racks=tiprack)\n\n    m300.well_bottom_clearance.aspirate = asp_height\n    m300.well_bottom_clearance.dispense = disp_height\n    m300.flow_rate.aspirate = asp_rate*m300.flow_rate.aspirate\n    m300.flow_rate.dispense = disp_rate*m300.flow_rate.dispense\n\n    # plate map excluding 1st column and row\n    # remove first comma in csv sample if found\n    if csv_samp[0] == ',':\n        csv_samp = csv_samp[1:]\n    plate_map = [[val.strip() for val in line.split(',')][1:]\n                 for line in csv_samp.splitlines()\n                 if line.split(',')[0].strip()][1:]\n\n    # FIND NUMBER OF TIPS PER COLUMN\n    letter_to_num = {'A': '1', 'B': '2', 'C': '3', 'D': '4',\n                     'E': '5', 'F': '6', 'G': '7', 'H': '8'}\n    num_tips_in_each_column = []\n\n    for column in range(24):\n        check_highest_letter = []\n        for row in plate_map:\n            well = row[column]\n            if '/' in well:\n                elements = well.split('/')\n                if elements[1] == '0' or elements[0] == '0':\n                    continue\n                else:\n                    check_highest_letter.append(int(\n                        letter_to_num[elements[1][0]]))\n        if len(check_highest_letter) > 0:\n            num_tips_in_each_column.append(max(check_highest_letter))\n        else:\n            num_tips_in_each_column.append('x')\n\n    # find start well\n    start_well = 0\n    for row in plate_map:\n        for well in row:\n            if '/' in well:\n                break\n            start_well += 1\n        if '/' in well:\n            break\n    start_row = math.floor(start_well/24)\n\n    # find control\n    check_control = []\n    for column in range(24):\n        for row in plate_map[::-1]:\n            well = row[column]\n            if '/' in well:\n                elements = well.split('/')\n                if elements[1] == '0':\n                    check_control.append(int(1))\n                    break\n                else:\n                    check_control.append(int(0))\n                    break\n\n    # add x's to the rest\n    for i, template in enumerate(plate_map[start_row]):\n        if 'x' in template or 'X' in template:\n            check_control.insert(i, 'x')\n\n    tip_count = 0\n\n    def pickup(num_channels_per_pickup):\n        nonlocal tip_count\n        tips_ordered = [\n            tip for rack in tiprack\n            for row in rack.rows()[\n                len(rack.rows())-num_channels_per_pickup::\n                -1*num_channels_per_pickup]\n            for tip in row]\n        m300.pick_up_tip(tips_ordered[tip_count])\n        tip_count += 1\n\n    # transfer target cell\n    dispense_wells = [list(j) for i, j in groupby(plate_map[start_row])]\n    wells_by_row = [well for row in plate.rows() for well in row]\n\n    def mix_diff_height(well):\n        m300.flow_rate.aspirate = m300.flow_rate.aspirate/asp_rate\n        m300.flow_rate.dispense = m300.flow_rate.dispense/disp_rate\n        for rep in range(premix_reps):\n            m300.aspirate(mix_vol,\n                          well.bottom(\n                           mix_asp_height),\n                          rate=mix_rate)\n            m300.dispense(mix_vol,\n                          well.bottom(\n                           mix_disp_height),\n                          rate=mix_rate)\n        m300.flow_rate.aspirate = asp_rate*m300.flow_rate.aspirate\n        m300.flow_rate.dispense = disp_rate*m300.flow_rate.dispense\n\n    def check_volume(counter, tot_vol, chunk, source_well):\n        if m300.current_volume < vol_target_cell:\n            if m300.current_volume > 0:\n                m300.dispense(m300.current_volume,\n                              source_well.bottom(disp_res_height))\n            if counter != len(chunk)-1:\n                if pre_mix:\n                    mix_diff_height(source_well)\n                m300.aspirate(tot_vol if tot_vol < 200 else\n                              200-0.15*vol_target_cell, source_well)\n\n    tip_col_ctr = 0\n\n    for j, chunk in enumerate(dispense_wells):\n        if 'x' in chunk or 'X' in chunk or chunk[0][0] == '0':\n            if j > 0:\n                start_well += len(chunk)\n                tip_col_ctr += len(chunk)\n            else:\n                tip_col_ctr += len(chunk)\n            continue\n\n        pickup(num_tips_in_each_column[tip_col_ctr]+check_control[tip_col_ctr])\n        tot_vol = vol_target_cell*len(chunk)*2+20\n        for i, well in enumerate(chunk):\n            source_well = target_res.wells_by_name()[str(chunk[0][0:2])]\n            if vol_target_cell >= 100:\n                if pre_mix:\n                    mix_diff_height(source_well)\n                m300.aspirate(vol_target_cell, source_well)\n                m300.dispense(vol_target_cell, wells_by_row[start_well])\n                if pre_mix:\n                    mix_diff_height(source_well)\n                m300.aspirate(vol_target_cell,\n                              source_well)\n                m300.dispense(vol_target_cell, wells_by_row[start_well+24])\n                start_well += 1\n                tip_col_ctr += 1\n\n            else:\n                if m300.current_volume < vol_target_cell:\n                    if pre_mix:\n                        mix_diff_height(source_well)\n                    m300.aspirate(tot_vol if tot_vol < 200\n                                  else 200-0.15*vol_target_cell,\n                                  source_well)\n\n                # first row dispense\n                m300.dispense(vol_target_cell, wells_by_row[start_well])\n                tot_vol -= vol_target_cell\n                check_volume(i, tot_vol, chunk, source_well)\n\n                # second row dispense\n                m300.dispense(vol_target_cell,\n                              wells_by_row[start_well+24])\n                tot_vol -= vol_target_cell\n                check_volume(i, tot_vol, chunk, source_well)\n\n                start_well += 1\n                tip_col_ctr += 1\n        if m300.current_volume > 0:\n            m300.dispense(m300.current_volume,\n                          source_well)\n        m300.drop_tip()\n        ctx.comment('\\n\\n')\n",
    "custom_labware_defs": [],
    "fields": [
        {
            "default": ",1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24\nnA,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnB,x,A1/A1,A2/A1,A2/A1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnC,x,A1/A1,A2/A1,A2/A1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnD,x,A1/B1,A2/B1,A2/B1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnE,x,A1/B1,A2/B1,A2/B1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnF,x,A1/C1,A2/C1,A2/C1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnG,x,A1/C1,A2/C1,A2/C1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnH,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnI,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnJ,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnK,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnL,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnM,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnN,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnO,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnP,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x\nnDay 1,30,Yes pre-mix,0.8,2,5,200,1,0.8,0.8,0.8,0.5,0.8,Right,,,,,,,,,,,\nnDay 2,30,Yes pre-mix,0.8,2,5,200,1,0.8,0.8,0.8,0.5,0.8,Right,,,,,,,,,,,",
            "label": ".CSV File",
            "name": "csv_samp",
            "type": "textFile"
        }
    ],
    "instruments": [
        {
            "mount": "right",
            "name": "p300_multi_gen2"
        }
    ],
    "labware": [
        {
            "name": "Corning 384 Well Plate 112 \u00b5L Flat on 4",
            "share": false,
            "slot": "4",
            "type": "corning_384_wellplate_112ul_flat"
        },
        {
            "name": "NEST 12 Well Reservoir 15 mL on 5",
            "share": false,
            "slot": "5",
            "type": "nest_12_reservoir_15ml"
        },
        {
            "name": "Opentrons 96 Filter Tip Rack 200 \u00b5L on 6",
            "share": false,
            "slot": "6",
            "type": "opentrons_96_filtertiprack_200ul"
        },
        {
            "name": "Opentrons Fixed Trash on 12",
            "share": false,
            "slot": "12",
            "type": "opentrons_1_trash_1100ml_fixed"
        }
    ],
    "metadata": {
        "apiLevel": "2.10",
        "author": "Rami Farawi <rami.farawi@opentrons.com>",
        "protocolName": "Cherrypicking with Multi-Channel Pipette and CSV",
        "source": "Custom Protocol Request"
    },
    "modules": []
}