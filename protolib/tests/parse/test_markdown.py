from protolib.parse import markdown
import os.path
import json

data_path = os.path.join(os.path.dirname(__file__), '../data')


def test_get_header():
    assert markdown.get_header('## Test 1\n') == 'Test 1'
    assert markdown.get_header('## Test') == 'Test'
    assert markdown.get_header('### Test\n') == 'Test'
    assert markdown.get_header('# Test\n') is None
    assert markdown.get_header('Test') is None
    assert markdown.get_header('') is None
    assert markdown.get_header('Test # Test') is None


def test_get_title():
    text = '# Title 1\n\ntext\n# Title 2'.splitlines()
    assert markdown.get_title(text) == 'Title 1'
    text = ''.splitlines()
    assert markdown.get_title(text) is None
    text = '## Foo\n'.splitlines()
    assert markdown.get_title(text) is None
    text = ''.splitlines()
    assert markdown.get_title(text) is None
    text = '# Title\n## Subtitle'.splitlines()
    assert markdown.get_title(text) == 'Title'


def test_header_to_key():
    res = markdown.header_to_key('time estimate')
    assert res == 'time-estimate'
    res = markdown.header_to_key('Foo')
    assert res == 'Foo'


def test_parse_list():
    text = '* foo\n* bar'
    assert markdown.parse_list(text) == ['foo', 'bar']
    text = '- foo\n- bar'
    assert markdown.parse_list(text) == ['foo', 'bar']
    text = 'foo'
    assert markdown.parse_list(text) == []
    text = '* foo\n\ntext\n\n* bar'
    assert markdown.parse_list(text) == ['foo', 'bar']


def test_convert_value():
    text = '* Cat1\n* Cat2'
    res = markdown.convert_value('categories', text)
    assert res == {'Cat1': [], 'Cat2': []}

    text = '* Cat1'
    res = markdown.convert_value('categories', text)
    assert res == {'Cat1': []}

    text = '*Test* protocol'
    res = markdown.convert_value('description', text)
    assert res == 'Test protocol'


def test_parse_headers_and_values():
    doc = {
        'Title': 'Test',
        'Categories': '* Cat1\n* Cat2'
    }
    res = markdown.parse_values(markdown.parse_headers(doc))
    assert res == {
        'title': 'Test',
        'categories': {'Cat1': [], 'Cat2': []}
    }


def test_split():
    text = '## Subsection\ntext'
    res = markdown.split_markdown(text.splitlines())
    assert res == {
        'Subsection': 'text'
    }

    text = '# Test\n## Section\ntext\n## Subsection\ntext'
    res = markdown.split_markdown(text.splitlines())
    assert res == {
        'title': 'Test',
        'Section': 'text',
        'Subsection': 'text'
    }

    res = markdown.split_markdown([])
    assert res == {}


def test_parse():
    res = markdown.parse(os.path.join(data_path, 'test.md'))
    # Note: The expected result data file is generated by printing
    # the json string of the res dictionary from markdown.parse. The
    # result dict manually verified and then onwards used as test data
    assert res == json.load(
        open(
            os.path.join(data_path, 'test_parse_expected.json')
        ))


def test_parse_nested_list():
    text1 = """* foo
    """

    res = markdown.parse_nested_list(text1)
    assert res == {'foo': []}

    text2 = """* foo
    * bar 1
    * bar 2
    """
    res = markdown.parse_nested_list(text2)
    assert res == {'foo': ['bar 1', 'bar 2']}

    text3 = """* foo
    * sub-foo 1
    * sub-foo 2
* bar
    * sub-bar 1
    * sub-bar 2
    """
    res = markdown.parse_nested_list(text3)
    text3_expected = {
        'foo': ['sub-foo 1', 'sub-foo 2'],
        'bar': ['sub-bar 1', 'sub-bar 2']
    }
    assert res == text3_expected

    text4 = """
    """
    res = markdown.parse_nested_list(text4)
    assert res == {}

    text4 = """* Foo
* Bar
* Baz
    """
    res = markdown.parse_nested_list(text4)
    assert res == {'Foo': [], 'Bar': [], 'Baz': []}
